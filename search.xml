<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis数据结构与对象(6)——压缩列表</title>
      <link href="/2019/02/12/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1-6-%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/"/>
      <url>/2019/02/12/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1-6-%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表<br>: (ziplist)是<strong>列表键(list)</strong>和<strong>哈希键(hash)</strong>的底层实现之一。当一个列表键只包含少量的列表项，并且每个列表项要么就是小整数值（具体见下文），要么就是长度比较短的字符串，那么Redis就会使用压缩列表来作为列表键的底层实现。<br><a id="more"></a></p><pre><code>redis&gt; RPUSH lst 1 3 5 10086 &quot;hello&quot; &quot;world&quot;&quot;6&quot;reids&gt; OBJECT ENCODING lst&quot;ziplist&quot;</code></pre><p>另外，当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。</p><pre><code>redis&gt; HMSET profile &quot;name&quot; &quot;Jack&quot; &quot;age&quot; 28 &quot;job&quot; &quot;Programmer&quot;&quot;OK&quot;reids&gt; OBJECT ENCODING profile&quot;ziplist&quot;</code></pre><h3 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h3><p>压缩列表顾名思义，是Redis为了节约内存而开发的，是<strong>由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结构</strong>。一个压缩列表可以包含任意多个<strong>节点(entry)</strong>，每个节点可以保存<strong>一个字节数组或一个整数值</strong>。</p><p>压缩列表的各个组成部分</p><table><thead><tr><th>zlbytes</th><th>zltail</th><th>zllen</th><th>entry1</th><th>entry2</th><th>…</th><th>entryN</th><th>zlend</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>压缩列表各个组成部分详细说明</p><table><thead><tr><th>属性</th><th>类型</th><th>长度</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td>zlbytes</td><td>uint32_t</td><td>4字节</td><td style="text-align:left">记录整个压缩列表占用的内存字节数（即压缩列表总长），在对压缩列表进行内存重分配或计算zlend的位置时使用</td></tr><tr><td>zltail</td><td>uint32_t</td><td>4字节</td><td style="text-align:left">记录压缩列表表尾节点距离压缩列表的起始地址(即zlbytes的起始地址)有多少个字节，通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾节点（即最后一个entry）的地址</td></tr><tr><td>zllen</td><td>uint16_t</td><td>2字节</td><td style="text-align:left">记录了压缩列表包含的节点（即entry）数量，当这个属性的值小于UINT16_MAX(65535)时，这个属性的值就是压缩列表包含节点的数量，当这个值等于65535时，节点的真是数量需要遍历整个压缩列表才能计算得出</td></tr><tr><td>entryX</td><td>列表节点</td><td>不定</td><td style="text-align:left">压缩列表包含的各个节点，节点的长度由节点保存的内容决定</td></tr><tr><td>zlend</td><td>uint8_t</td><td>1字节</td><td style="text-align:left">特殊值0xFF(十进制255)，用于标记压缩列表的末端</td></tr></tbody></table><h3 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h3><table><thead><tr><th>previous_entry_length</th><th>encoding</th><th>content</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>每个压缩列表<strong>节点</strong>可以保存一个<strong>字节数组</strong>或者一个<strong>整数值</strong>，其中，字节数组可以是一下三种长度之一：</p><ul><li>长度小于等于63（2^6-1)字节的字节数组</li><li>长度小于等于16383（2^14-1）字节的字节数组</li><li>长度小于等于4294967295（2^32-1）字节的字节数组<br>而整数值则可以是一下六种长度之一：</li><li>4位长，介于0-12之间的无符号整数</li><li>1字节长的有符号整数</li><li>3字节长的有符号整数</li><li>int16_t类型整数</li><li>int32_t类型整数</li><li>int64_t类型整数</li></ul><p>每个压缩列表节点都由<code>previous_entry_length</code>、<code>encoding</code>、<code>content</code>三个部分组成。</p><h4 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h4><p>节点的<code>previous_entry_length</code>属性以字节位单位，记录了压缩列表中前一个节点的长度。<code>previous_entry_length</code>属性的长度可以是<strong>1字节</strong>或者<strong>5字节</strong>。</p><ul><li>如果前一节点的长度小于254字节，那么<code>previous_entry_length</code>属性的长度为1字节，前一个节点的长度就保存在这一个字节中（如0x05，表示前一个节点为5字节）</li><li>如果前一个的长度大于254字节，那么<code>previous_entry_length</code>属性的长度为5字节，其中属性的第一字节会被设置为0xFE（十进制254），而之后的四个字节则用于保存前一节点的长度（如0xFE00002766，0x00002766十进制为10086，表示前一个节点长度为10086）</li></ul><p>因为节点的<code>previous_entry_length</code>属性记录了前一个节点的长度，所以程序可以通过指针运算，根据当前的起始地址计算出前一个节点的起始地址。压缩列表的从表尾向表头遍历操作就是使用这一原理实现的。</p><h4 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h4><p>节点的<code>encoding</code>属性记录了节点的<code>content</code>属性所保存数据的类型以及长度</p><ul><li>一字节、两字节或者五字节长，值的最高位为<strong>00、01或者10</strong>的是<strong>字节数组编码</strong>，这种编码表示节点的<code>content</code>属性保存着字节数组，数组的<strong>长度</strong>由编码除去最高两位之后的其他位记录</li><li>一字节长，值的最高位<strong>以11开头</strong>的是<strong>整数编码</strong>，这种编码表示节点的<code>content</code>属性保存着整数值，整数值的<strong>类型和长度</strong>由编码除去最高两位之后的其他位记录</li></ul><p>字节数组编码</p><table><thead><tr><th>编码</th><th>编码长度</th><th>content属性保存的值</th></tr></thead><tbody><tr><td>00xxxxxx</td><td>1字节</td><td>长度小于等于63字节的字节数组</td></tr><tr><td>01xxxxxx yyyyyyyy</td><td>2字节</td><td>长度小于等于16383字节的字节数组</td></tr><tr><td>10______ xxxxxxxx yyyyyyyy zzzzzzzz aaaaaaaa</td><td>5字节</td><td>长度小于等于4294967295字节的字节数组</td></tr></tbody></table><p>整数编码</p><table><thead><tr><th>编码</th><th>编码长度</th><th>content属性保存的值</th></tr></thead><tbody><tr><td>11000000</td><td>1字节</td><td>int16_t类型的整数</td></tr><tr><td>11010000</td><td>1字节</td><td>int32_t类型的整数</td></tr><tr><td>11100000</td><td>1字节</td><td>int64_t类型的整数</td></tr><tr><td>11110000</td><td>1字节</td><td>24位有符号整数</td></tr><tr><td>11111110</td><td>1字节</td><td>8位有符号整数</td></tr><tr><td>1111xxxx</td><td>1字节</td><td>使用这一编码的节点没有相应的content属性，因为编码本身的xxxx四个位已经保存了一个介于0-12的值，所以它无须content属性</td></tr></tbody></table><h4 id="content"><a href="#content" class="headerlink" title="content"></a>content</h4><p>节点的<code>content</code>属性负责保存节点的值，节点值可以是一个字节数组或整数，值的类型和长度由节点的<code>encoding</code>属性决定。例如：</p><table><thead><tr><th style="text-align:center">previous_entry_length</th><th>encoding</th><th>content</th></tr></thead><tbody><tr><td style="text-align:center">xxx</td><td>00001011</td><td>“hello world”</td></tr></tbody></table><ul><li>编码最高位00表示节点保存的是一个字节数组</li><li>编码后六位001011记录了字节数组长度为11</li><li>content属性保存了节点值字符串</li></ul><h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>前面说过，每个节点的<code>previous_entry_length</code>属性都记录了前一个节点的长度，现在考虑这样一种情况，在一个压缩列表中，又多个连续的、长度介于250字节到253字节之间的节点e1至eN</p><table><thead><tr><th>zlbytes</th><th>zltail</th><th>zllen</th><th>entry1</th><th>entry2</th><th>…</th><th>entryN</th><th>zlend</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>因为e1至eN所有节点的长度都小于254字节，所以记录这些节点的长度只需要1字节长的<code>previous_entry_length</code>属性，这时，如果我们将一个长度大于等于254字节的新节点new设置为压缩列表的表头节点</p><table><thead><tr><th>zlbytes</th><th>zltail</th><th>zllen</th><th>new-entry</th><th>entry1</th><th>…</th><th>entryN</th><th>zlend</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>因为e1的<code>previous_entry_length</code>属性仅长1字节，无法保存新节点的长度，所以程序将对压缩列表执行空间重分配操作，并将e1节点的<code>previous_entry_length</code>属性从原来的1字节扩展为5字节。现在，问题来了，e1之前介于250字节到253字节，现在新增四个字节，e1长度必定大于254字节，因此e2也保存不下，得再次对压缩列表执行空间重分配操作，正如e1引发了e2的扩展，e2也会引发e3的扩展……直到eN为止。<br>Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为<strong>“连锁更新(cascade)”</strong>，除了添加新节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新(如下，删除small节点，entry1会扩展为5字节）。</p><table><thead><tr><th>zlbytes</th><th>zltail</th><th>zllen</th><th>big(大于254)</th><th>small(小于254)</th><th>entry1</th><th>…</th><th>entryN</th><th>zlend</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>因为连锁更新在最坏的情况下需要对压缩列表执行N次空间重分配操作，二每次空间重分配最坏的复杂度为<code>O(N)</code>(即从entry1开始分配)，所以连锁更新最坏复杂度为<code>O(N^2)</code>，即压缩列表的很多API最坏复杂度为<code>O(N^2)</code>，如ziplistPush等。但是尽管连锁更新的复杂度较高，但是可能性几率不大，或者节点数少也不会造成太大性能问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>压缩列表是一种为节约内存而开发的顺序性数据结构</li><li>压缩列表被用作列表键和哈希键的底层实现之一</li><li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值</li><li>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构与对象(5)——整数集合</title>
      <link href="/2019/01/31/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(5)%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
      <url>/2019/01/31/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(5)%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合<br>: (intset)是<strong>集合键（set）</strong>的底层实现之一，当一个集合只包含整数值元素（浮点数会让set的object encoding 变成hashtable），并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。<br><a id="more"></a></p><pre><code>redis&gt; SADD numbers 1 3 4 5&quot;4&quot;reids&gt; OBJECT ENCODING numbers&quot;intset&quot;redis&gt; SADD numbers 1.1&quot;1&quot;redis&gt; OBJECT ENCODING numbers&quot;hashtable&quot;</code></pre><h3 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h3><p>整数集合是Redis用于保存整数值的集合抽象数据结构，可以保存类型为<code>int16_t</code>、<code>int32_t</code>、<code>int64_t</code>的整数值，并且保证集合中不会出现重复元素。</p><p>整数集合<br>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding; <span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length; <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[]; <span class="comment">//保存元素的数组</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure></p><p>contents数组是整数集合的底层实现：整数集合的每个元素都是<code>contents</code>数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。<br>虽然intset将contents属性声明为int8_t类型数组，但实际上<code>contents</code>数组并并不保存任何<code>int8_t</code>类型的值，contents数组的真正类型取决于<code>encoding</code>属性的值，即如果<code>encoding</code>属性的值为<code>INTSET_ENC_INT16</code>，那么<code>contents</code>就是一个<code>int16_t</code>类型的数组，数组里每个元素占16位。</p><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。升级并添加分为三步进行：</p><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变</li><li>将新元素添加到底层数组里面</li></ol><p>举个例子：有一个<code>INTSET_ENC_INT16</code>编码的整数集合，集合中有1，2，3这三个<code>int16_t</code>的元素，底层数组的大小为<code>3*16=48</code>位。若把<code>int32_t</code>类型的65535添加到集合中，必须要对整个集合进行升级。首先要分配四个元素的空间，即<code>36*4=128</code>位。接下来把三个元素转换成<code>int32_t</code>类型，并放置到正确位上面，且维持有序性不变。最后将第四个元素加入，将整数集合encoding属性值从<code>INTSET_ENC_INT16</code>改为<code>INTSET_ENC_INT32</code>，并将<code>length</code>属性的值从3改为4。</p><p>因为每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已有的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为<code>O(N)</code>。</p><p>升级的好处：</p><ol><li>提升灵活性：因为C是静态类型语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面。但是，因为整数集合可以通过自动升级底层数组来适应新元素，所以我们可以随意将<code>int16_t</code>、<code>int32_t</code>、<code>int64_t</code>的整数添加到集合中，而不必担心出现类型错误</li><li>节约内存：当然，要让有一个数组可以同时保存<code>int16_t</code>、<code>int32_t</code>、<code>int64_t</code>的整数最简单的做法就是直接使用<code>int64_t</code>类型的数组作为整数集合的底层实现。不过这样一来会造成内存浪费的情况，而整数集合现在的做法既可以让集合能同时保存三种不同类型的值，又可以确保升级操作只会在有需要的时候进行，这可以尽量节省内存。</li></ol><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持在升级后的状态。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>整数集合是集合键的底层实现之一</li><li>整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型</li><li>升级操作为整数集合带来了操作上的灵活性，并且尽可能节约了内存</li><li>整数集合只支持升级操作，不支持降级操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> intset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构与对象(4)——跳跃表</title>
      <link href="/2019/01/31/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(4)%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
      <url>/2019/01/31/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(4)%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表<br>: (skiplist)是一种有序的数据结构，支持平均<em>O</em>(log<em>N</em>)、最坏<em>O</em>(<em>N</em>)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。大部分情况下，跳跃表的效率可以和平衡树相媲美，且实现更为简单。<br><a id="more"></a><br>Redis使用跳跃表作为<strong>有序集合键(zset)</strong>的底层实现之一，如果一个有序集合包含的<strong>元素数量较多</strong>，又或者有序集合中的元素成员(member)是比<strong>较长的字符串</strong>时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>例如<br>: fruit-price是一个有序集合键，这个有序集合以水果名为成员，水果价钱为分值，保存了130款水果的价钱</p><pre><code>redis&gt; ZRANGE fruit-price 0 2 WITHSCORES1)&quot;banana&quot;2)&quot;5&quot;3)&quot;cherry&quot;4)&quot;6.5&quot;5)&quot;apple&quot;6)&quot;8&quot;redis&gt; ZCARD fruit-price(integer) 130</code></pre><p>fruit-price有序集合的所有数据都保存在一个跳跃表里面，其中每个跳跃表节点(node)都保存了一款水果的价钱信息，所有水果按价钱的高低从低到高在跳跃表里面排序。</p><p>和链表、字典等数据结构被广泛地应用在Redis内部不一样，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外跳跃表在Redis中没有其他用途。</p><h3 id="跳跃表原理"><a href="#跳跃表原理" class="headerlink" title="跳跃表原理"></a>跳跃表原理</h3><p>性质<br>: </p><ol><li>由很多层结构组成；</li><li>每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；</li><li>最底层的链表包含了所有的元素；</li><li>如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；</li><li>链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；</li></ol><p><img src="http://odwv9d2u8.bkt.clouddn.com/17-10-3/32571293.jpg" alt="跳跃表"></p><p>搜索<br>: 其基本原理就是从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。</p><p><img src="http://odwv9d2u8.bkt.clouddn.com/17-10-3/6620991.jpg" alt="跳跃表"></p><p>插入<br>: 既然要插入，首先需要确定插入的层数，这里有不一样的方法。1. 抛硬币法，只要是正面就累加，直到遇见反面才停止，最后记录正面的次数并将其作为要添加新元素的层；2. 统计概率，先给定一个概率p，产生一个0到1之间的随机数，如果这个随机数小于p，则将高度加1，直到产生的随机数大于概率p才停止，根据给出的结论，当概率为1/2或者是1/4的时候，整体的性能会比较好（其实当p为1/2的时候，也就是抛硬币的方法）。</p><p>当确定好要插入的层数以后，则需要将元素都插入到从最底层到第k层。</p><p>删除<br>: 在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。</p><h3 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h3><p>Redis的跳跃表由<code>redis.h/zskiplistNode</code>和<code>redis.h/zskiplist</code>两个结构定义，其中<code>zskiplistNode</code>结构用于表示跳跃表节点，而<code>zskiplist</code>结构则用于保存跳跃表节点的相关信息，比如结点的数量，指向表头节点和表位节点的指针等等。</p><p><img src="https://images2015.cnblogs.com/blog/878314/201701/878314-20170130211615120-320409943.png" alt="一个跳跃表"></p><p>上图展示了一个跳跃表示例，位于图片最左边的是<code>zskiplist</code>结构，该结构包含以下属性：</p><ul><li>header：指向跳跃表的表头节点</li><li>tail：指向跳跃表的表尾节点</li><li>level：记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</li><li>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</li></ul><p>位于<code>zskiplist</code>结构右方的是四个<code>zskiplistNode</code>结构，该结构包含以下属性：</p><p><strong>层(level)</strong>：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，依次类推。每个层都带有两个属性：<strong>前进指针</strong>和<strong>跨度</strong>。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</p><p><strong>后退(backward)指针</strong>：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</p><p><strong>分值(score)</strong>：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</p><p><strong>成员对象(obj)</strong>：各个节点中的o1、o2和o3是节点所保存的成员对象。<br>  注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到，所以图中省略了这些部分，只显示了表头节点的各个层。</p><p>跳跃表节点<br>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">//后退指针</span></span><br><span class="line">    <span class="keyword">double</span> score;<span class="comment">//分值</span></span><br><span class="line">    robj *obj;<span class="comment">//成员对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span> <span class="comment">//层</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span>  <span class="comment">//前进指针</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;  <span class="comment">//跨度</span></span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></p><ol><li><p>层：跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。<br>每次创建一个新跳跃表节点的时候，程序根据幂次定律(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。<br>下图分别展示了三个高度为1层、3层和5层的节点，因为C语言的数组索引总是从0开始的，所以节点的第一层是level[0]，而第二层是level[1]，依次类推。</p></li><li><p>前进指针</p></li><li><p>跨度：层的跨度(<code>level[i].span</code>属性)用于记录两个节点之间的距离：两个节点之间的跨度越大，它们相距得就越远。指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样的，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位(rank)的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p></li><li><p>后退指针：节点的后退指针(backward属性)用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p></li><li><p>分值和成员：节点的分值(score属性)是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。<br>节点的成员对象(obj属性)是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。<br>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分至相同的节点将按照成员对象在字典中的大小来进行排序，成员对象较小的节点会排在前面(靠近表头的方向)，而成员对象较大的节点则会排在后面(靠近表尾的方向)。</p></li></ol><p>跳跃表<br>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>    <span class="comment">//header指向跳跃表的表头节点，tail指向跳跃表的表尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;   <span class="comment">//记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</span></span><br><span class="line">    <span class="keyword">int</span> level;  <span class="comment">//记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure></p><p>header和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为<em>O</em>(1)。<br>通过length属性，可以在<em>O</em>(1)复杂度内返回跳跃表的长度。<br>level属性用于在<em>O</em>(1)复杂度内获取跳跃表中层高最大的那个节点的层数量（不计算表头节点的层高）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>跳跃表是有序集合的底层实现之一</li><li>Redis的跳跃表实现由<code>zskiplist</code>和<code>zskiplistNode</code>两个结构组成，其中<code>zskiplist</code>用于保存跳跃表信息（表头节点、表尾节点、长度），而<code>zskiplistNode</code>则用于表示跳跃表节点</li><li>每个跳跃表节点的层高都是1至32之间的<strong>随机数</strong></li><li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象（指向SDS的一个指针）必须是唯一的</li><li>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象在字典序中的大小进行排序</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 跳跃表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构与对象(3)——字典</title>
      <link href="/2019/01/31/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(3)%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/"/>
      <url>/2019/01/31/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(3)%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典，又称为符号表(symbol table)、关联数组(associative array)或映射(map)，是一种用于保存键值对的抽象数据结构。字典中的每个键都是独一无二的，程序可以在字典中通过键查找与之关联的值，或进行更新删除等操作。<br><a id="more"></a><br>Redis的数据库就是使用字典来作为底层实现的。例如：</p><pre><code>redis&gt;SET msg &quot;hello world&quot;OK</code></pre><p>在数据库中创建了一个键为”msg”,值为”hello world”的键值对，保存在字典中。<br>除了用来表示数据库外，字典还是<strong>哈希键</strong>的底层实现之一。</p><pre><code>redis&gt;  HMSET user name &quot;kendall&quot; sex &quot;man&quot;OKredis&gt;  HGETALL user1) &quot;name&quot;2) &quot;kendall&quot;3) &quot;sex&quot;4) &quot;man&quot;</code></pre><p><code>user</code>就是一个一个包含2个键值对的哈希键。</p><p>Redis的字典使用哈希表作为底层实现，一个哈希表可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><p>哈希表<br>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;<span class="comment">//哈希表大小掩码，总是等于size-1，用于计算索引值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure></p><p><code>table</code>是一个数组，数组中的每一个元素都是一个指向dictEntry结构的指针，每个dictEntry结构都保存着一个键值对。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> key;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span><span class="comment">//哈希冲突时，采用链表法解决</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure></p><p>字典<br>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    dictType *type;<span class="comment">//类型特定函数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;<span class="comment">//私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];<span class="comment">//哈希表</span></span><br><span class="line">    <span class="keyword">int</span> trehashidx;<span class="comment">//rehash索引，当rehash不进行时，为-1；</span></span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure></p><p>了解：<code>type</code>属性是指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，<code>privdate</code>保存了传给那些函数的可选参数。</p><p><code>ht</code>是一个长度为2的数组，包含了两个dictht哈希表。一般情况下字典只使用<code>ht[0]</code>哈希表，<code>ht[1]</code>只有在进行rehash的时候使用。<code>rehashidx</code>记录了rehash的进度。</p><p>哈希算法<br>: 当要将一个新的键值对添加到字典时，程序需要先根据键值对的键计算出哈希值和索引值，然后根据索引值将节点放到韩系标书组的指定索引上面。Redis使用MurmurHash2算法来计算哈希值(Redis v3.0)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure></p><h3 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h3><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上时，我们称这些键发生了冲突。Redis的哈希表使用了<strong>链地址法</strong>解决键冲突，每个哈希表节点都由一个next指针，被分配到同一个索引上的节点可以用next连接成单向链表，新加入的节点总是排在所有节点的前面。</p><h3 id="扩容（收缩）和rehash"><a href="#扩容（收缩）和rehash" class="headerlink" title="扩容（收缩）和rehash"></a>扩容（收缩）和rehash</h3><p>哈希表的键值对会逐渐的增加或减少，为了让哈希表的负载因子(load factor)，维持在一个合理的范围，程序需要对哈希表进行相应的扩容或收缩。当满足<br>以下两点任意一点时，扩容开始。当满足负<strong>载因子小于0.1</strong>时，进行收缩。</p><ol><li>服务器目前没有在执行<em>BGSAVE</em>命令或者<em>BGREWRITEAOF</em>命令，并且哈希表的负载因子大于等于1</li><li>服务器目前正在执行<em>BGSAVE</em>命令或者<em>BGREWRITEAOF</em>命令，并且哈希表的负载因子大于等于5</li></ol><p>其中负载因子计算方法为：</p><pre><code>load_factor = ht[0].used/dictht.size</code></pre><p>步骤如下：</p><ol><li>为字典的<code>ht[1]</code>分配空间，如果执行的是扩展操作，那么<code>ht[1]</code>的大小为大于等于<code>ht[0].used*2</code>的最小2^n；若是收缩操作，那么<code>ht[1]</code>的大小为大于等于<code>ht[0].used</code>的最小2^n。</li><li>将保存在<code>ht[0]</code>中的所有键值对rehash（重新计算键的哈希和索引）到<code>ht[1]</code>上，并将键值对放置到<code>ht[1]</code>。</li><li>当<code>ht[0]</code>的所有键值对都迁移到了<code>ht[1]</code>上后，释放<code>ht[0]</code>，将<code>ht[1]</code>设置为<code>ht[0]</code>，并在<code>ht[1]</code>新建一个空白的哈希表，为下一次rehash做准备。</li></ol><p>Redis的rehash时<strong>渐进式</strong>的，即不是一次性、集中式完成的，而是分多次完成。这样做是避免键值对过多时，庞大的计算量导致服务器停止服务。渐进式的步骤如下：</p><ol><li>为<code>ht[1]</code>分配空间</li><li>在字典中维持<code>rehashidx</code>,将其值设置为0，表示rehash正式开始</li><li>在rehash期间，每次对字典的增删查改，程序都会顺带将<code>ht[0]</code>哈希表在<code>rehashidx</code>索引上的所有键值对rehash到<code>ht[1]</code>，当rehash工作完成后，<code>rehashidx</code>增加1</li><li>随着字典操作不断执行，最终某个时间上，ht[0]的所有键值对都会被rehash至<code>ht[1]</code>,<code>rehashidx</code>设为-1，代表rehash完成。</li><li>rehash过程中，字典会同时使用两个哈希表，如<code>ht[0]</code>没找到，会继续去<code>ht[1]</code>找。而添加一律会被保存在<code>ht[1]</code>。</li></ol><p>举例: <code>set msg HelloWorld</code>这个命令执行以后，redis会在<code>dict-&gt;ht-&gt;dictht-&gt;table</code>中加入一个<code>dictEntry</code>，entry的位置由<code>dict</code>内置的hash算法(比如MurmurHash2)与大小掩码作与运算得出，这个<code>dictEntry</code>包含了<code>key-value</code>和<code>next</code>属性，key和value是redis的<code>SDS</code>简单动态字符串的抽象类。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>字典被广泛用于实现Redis（远程字典服务）的各种功能，其中包括数据库和哈希键。</li><li>Redis中的字典使用哈希表作为底层实现，每个字典待优两个哈希表，一个平时使用，另一个仅在进行rehash时使用</li><li>Redis目前使用MurmurHash2算法计算键的哈希值</li><li>哈希表使用链地址法来解决冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表</li><li>在对哈希表进行扩展或收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程不是一次性完完成的，而是伴随着每一次增删改查渐进式完成的</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 字典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构与对象(2)——链表</title>
      <link href="/2019/01/31/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(2)%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/01/31/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(2)%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表提供了高效的节点重排能力，以及顺序性节点的访问方式，并且可以通过增删节点来灵活地调整长度。Redis中的<strong>列表键</strong>(list)的底层实现之一就是链表。当一个链表键包含了较多元素，又或者列表中包含的元素都是较长的字符串时，Redis就会使用链表作为列表键的底层实现。（实际上链表还被广泛用于实现Redis的各种功能，比如发布与订阅、慢查询、监视器等）<br><a id="more"></a></p><pre><code>redis&gt;LLEN integers(integer) 1024redis&gt;LRANGE integers 0 31)&quot;1&quot;2)&quot;2&quot;3)&quot;3&quot;</code></pre><p>integers列表键底层实现就是一个链表，每个节点都保存了一个整数值。</p><p>Redis链表的实现<br>: 每个链表节点都包含了指向prev和next的两个指针，同时还有保存节点值的value指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure></p><p>Redis list结构<br>: list结构为链表提供了表头指针，表尾指针，以及链表长度计数器len，这么做的好处是获取prev和next节点、获取head和tail节点、获取链表长度的时间复杂度均为O(1)。此外还提供了三个特定函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> *(*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> *(*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构与对象(1)——简单动态字符串SDS</title>
      <link href="/2018/12/28/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(1)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/"/>
      <url>/2018/12/28/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(1)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/</url>
      
        <content type="html"><![CDATA[<h2 id="简单动态字符串-SDS"><a href="#简单动态字符串-SDS" class="headerlink" title="简单动态字符串-SDS"></a>简单动态字符串-SDS</h2><p>Redis是由C语言编写的，但Redis没有直接使用C语言传统的字符串表示，而是自己构建了一种叫做简单动态字符串（simple dynamic string, SDS）的抽象类型，除了用来保存字符串外，SDS还被用作缓冲区，如AOF缓冲区。<br><a id="more"></a><br>当你在redis客户端执行命令：</p><pre><code>redis&gt;SET msg &quot;hello world&quot;OK</code></pre><p>那么Redis将会创建一个新的键值对，而这个键值对的键”msg”和键值对的值”hello world”底层实现就是保存了字符串的SDS。</p><p>SDS定义<br>: </p><pre><code class="c"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>{</span>        <span class="keyword">int</span> len; <span class="comment">//记录buf数组中已使用的字节的数量</span>        <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">//记录buf数组中未使用的字节的数量</span>        <span class="keyword">char</span> buf[]; <span class="comment">//保存字符串char的数组</span>    }</code></pre><p>SDS的结构其实就是一个字节数组，如字符串”redis”，那么buf就是一个保存了[‘r’,’e’,’d’,’i’,’s’,’\0’]的char数组（’\0’是C语言的一个惯例，redis遵守这个惯例是为了直接重用C库里的一些字符串函数）</p><h4 id="为什么要用SDS？"><a href="#为什么要用SDS？" class="headerlink" title="为什么要用SDS？"></a>为什么要用SDS？</h4><p>C语言使用的字符串方式，并不能满足Redis对字符串安全性、效率以及功能的要求。</p><ol><li><p><strong>常数复杂度获取字符串长度</strong>：C获取字符串长度复杂度为O(<em>N</em>)，而SDS保存了len属性，获取字符串长度复杂度为O(1)</p></li><li><p><strong>杜绝缓冲区溢出</strong>：C字符串不记录自身长度带来的另一个问题就是容易造成缓冲区溢出，例如内存中紧邻的s1-“redis”和s2-“mongo”，如果此时执行<code>strcat(s1,&quot;cluster&quot;)</code>，且没有在此之前为s1分配足够的空间，那么s2保存的内容将被意外的修改。与C不同，当SDS的API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需，不满足的话，API会自动将SDS的空间扩展至所需修改的大小，然后再进行实际的修改，所以SDS不需要手动修改SDS的空间大小，也不会出现缓冲区溢出问题。</p></li><li><p><strong>减少修改字符串时带来的内存重分配次数</strong>：C在每次进行字符串修改时（增长或缩短），总要进行一次内存重分配操作，而内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以比较耗时。为了避免这个缺陷，SDS通过未使用空间接触字符串长度和底层数组长度的关联。buf的数组长度可能包含未使用的字节，由free属性记录。实际上SDS用未使用空间实现了两种优化策略。<br>3.1 <strong>空间预分配</strong>：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须的空间，还会分配额外的未使用空间。若修改后的SDS长度（len属性）小于1MB，那么分配和len属性同样大小的未使用空间，即buf的实际长度为<code>len+len+1byte</code>;若长度大于1MB，那么程序会分配1MB的未使用空间，即buf的实际长度为<code>lne+1MB+1byte</code>。<br>3.2 <strong>惰性空间释放</strong>：执行字符串缩短操作后，SDS并不会立即释放多余的空间，而是保留作为未使用空间，以减少内存重分配操作，并未将来可能的增长提供优化。当然SDS也提供主动释放空间的API。</p></li><li><p><strong>二进制安全</strong>：C以”\0”为结尾标记，若有使用此特殊字符的字符串，则无法用C字符串保存。而SDS虽然保留了C以”\0”结尾的惯例，但并不以此来识别字符串是否结束，可以说数据在写入SDS是什么样的，它被读取出来就是什么样的。因此二进制安全的SDS可以保存任意格式的二进制数据。</p></li><li><p><strong>兼容部分的C字符串函数</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> SDS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
