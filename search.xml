<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis数据结构与对象(7)——quicklist]]></title>
    <url>%2F2019%2F03%2F18%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(7)%E2%80%94%E2%80%94quicklist%2F</url>
    <content type="text"><![CDATA[quicklistRedis3.2分支以后引入了一种新的内部数据结构——quicklist，quicklist经常被用作列表键的实现之一，4.0版本以后取消了列表键对象的ziplist和linkedlist编码，统一使用quicklist编码。 redis&gt; RPUSH lst 1 3 5 10086 &quot;hello&quot; &quot;world&quot; &quot;6&quot; reids&gt; OBJECT ENCODING lst &quot;quicklist&quot; quicklist的构成Redis4.0版本以后用自定义的一种复杂数据结构quicklist取代了ziplsit和linkedlist，它本身是一个双向无环链表，它的每一个节点都是一个ziplist，可以看出quicklist其实是将ziplist和linkedlist结合到了一个数据结构中。为什么这么设计呢？ 链表在插入，删除节点的时间复杂度很低；但是内存利用率低，且由于内存不连续容易产生内存碎片 压缩表内存连续，存储效率高；但是插入和删除的成本太高，需要频繁的进行数据搬移、释放或申请内存（每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能）。 而quicklist通过将每个压缩表用双向链表的方式连接起来，来寻求一种收益最大化。 定义首先是quicklist的节点quicklistNode： 123456789101112typedef struct quicklistNode &#123; struct quicklistNode *prev; struct quicklistNode *next; unsigned char *zl; // ziplist unsigned int sz; // ziplist的内存大小 unsigned int count : 16; // zpilist中数据项的个数 unsigned int encoding : 2; // 1为ziplist 2是LZF压缩存储方式 unsigned int container : 2; unsigned int recompress : 1; // 压缩标志, 为1 是压缩 unsigned int attempted_compress : 1; // 节点是否能够被压缩,只用在测试 unsigned int extra : 10; /* more bits to steal for future usage */&#125; quicklistNode; quicklistNode实际上就是对ziplist的进一步封装，其中包括： prev: 指向链表前一个节点的指针。 next: 指向链表后一个节点的指针。zl: 数据指针。如果当前节点的数据没有压缩，那么它指向一个ziplist结构；否则，它指向一个quicklistLZF结构。 sz: 表示zl指向的ziplist的总大小（包括zlbytes, zltail, zllen, zlend和各个数据项）。需要注意的是：如果ziplist被压缩了，那么这个sz的值仍然是压缩前的ziplist大小。 count: 表示ziplist里面包含的数据项个数。这个字段只有16bit。稍后我们会一起计算一下这16bit是否够用。 encoding: 表示ziplist是否压缩了（以及用了哪个压缩算法）。目前只有两种取值：2表示被压缩了（而且用的是LZF压缩算法），1表示没有压缩。 container: 是一个预留字段。本来设计是用来表明一个quicklist节点下面是直接存数据，还是使用ziplist存数据，或者用其它的结构来存数据（用作一个数据容器，所以叫container）。但是，在目前的实现中，这个值是一个固定的值2，表示使用ziplist作为数据容器。 recompress: 当我们使用类似lindex这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置recompress=1做一个标记，等有机会再把数据重新压缩。 attempted_compress: 这个值只对Redis的自动化测试程序有用。我们不用管它。 extra: 其它扩展字段。目前Redis的实现里也没用上。 quicklistLZF结构表示一个被压缩过的ziplist。其中： sz: 表示压缩后的ziplist大小。 compressed: 是个柔性数组（flexible array member），存放压缩后的ziplist字节数组。 quicklist: 12345678typedef struct quicklist &#123; quicklistNode *head; // 头结点 quicklistNode *tail; // 尾节点 unsigned long count; // 所有数据的数量 unsigned int len; // quicklist节点数量 int fill : 16; // 单个ziplist的大小限制 unsigned int compress : 16; // 压缩深度&#125; quicklist; 真正表示quicklist的数据结构是同名的quicklist这个struct： head: 指向头节点（左侧第一个节点）的指针。 tail: 指向尾节点（右侧第一个节点）的指针。 count: 所有ziplist数据项的个数总和。 len: quicklist节点的个数。 fill: 16bit，ziplist大小设置，存放list-max-ziplist-size参数的值。 compress: 16bit，节点压缩深度设置，存放list-compress-depth参数的值。 quicklistNode的大小到底一个quicklistNode节点包含多长的ziplist合适呢？比如，同样是存储12个数据项，既可以是一个quicklist包含3个节点，而每个节点的ziplist又包含4个数据项，也可以是一个quicklist包含6个节点，而每个节点的ziplist又包含2个数据项。 这又是一个需要找平衡点的难题。我们只从存储效率上分析一下： 每个quicklist节点上的ziplist越短，则内存碎片越多。内存碎片多了，有可能在内存中产生很多无法被利用的小碎片，从而降低存储效率。这种情况的极端是每个quicklist节点上的ziplist只包含一个数据项，这就蜕化成一个普通的双向链表了。 每个quicklist节点上的ziplist越长，则为ziplist分配大块连续内存空间的难度就越大。有可能出现内存里有很多小块的空闲空间（它们加起来很多），但却找不到一块足够大的空闲空间分配给ziplist的情况。这同样会降低存储效率。这种情况的极端是整个quicklist只有一个节点，所有的数据项都分配在这仅有的一个节点的ziplist里面。这其实蜕化成一个ziplist了。 可见，一个quicklist节点上的ziplist要保持一个合理的长度。那到底多长合理呢？这可能取决于具体应用场景。实际上，Redis提供了一个配置参数list-max-ziplist-size，就是为了让使用者可以来根据自己的情况进行调整。 list-max-ziplist-size -2 我们来详细解释一下这个参数的含义。它可以取正值，也可以取负值。 当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置成5的时候，表示每个quicklist节点的ziplist最多包含5个数据项。当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5这五个值，每个值含义如下： -5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb =&gt; 1024 bytes） -4: 每个quicklist节点上的ziplist大小不能超过32 Kb。 -3: 每个quicklist节点上的ziplist大小不能超过16 Kb。 -2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值） -1: 每个quicklist节点上的ziplist大小不能超过4 Kb。 为正数时，表示单个节点最大允许的元素个数，最大为32768个 当列表很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率比较低（访问起来性能也很低）。如果应用场景符合这个特点，那么list还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。Redis的配置参数list-compress-depth就是用来完成这个设置的。 list-compress-depth 0 这个参数表示一个quicklist两端不被压缩的节点个数。注：这里的节点个数是指quicklist双向链表的节点个数，而不是指ziplist里面的数据项个数。实际上，一个quicklist节点上的ziplist，如果被压缩，就是整体被压缩的。 参数list-compress-depth的取值含义如下： 0: 是个特殊值，表示都不压缩。这是Redis的默认值。 1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。 2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。 3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。依此类推… 由于0是个特殊值，很容易看出quicklist的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取。 Redis对于quicklist内部节点的压缩算法，采用的LZF——一种无损压缩算法。 总结 quicklist除了常用的增删改查外还提供了merge、将ziplist转换为quicklist等API quicklist是Redis3.2分支后在ziplist和linkedlist两种数据结构的基础上融合而成的一个实用的复杂数据结构 quicklist在4.0之后取代了linkedlist和ziplist作为list的基础数据类型 quicklist的大部分API都是直接复用ziplist quicklist的单个节点最大存储默认为8kb quicklist提供了基于LZF算法的压缩API，通过将不常用的中间节点数据压缩达到节省内存的目的]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据结构</tag>
        <tag>quicklist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP和HTTPS]]></title>
    <url>%2F2019%2F02%2F20%2FHTTP%E5%92%8CHTTPS%2F</url>
    <content type="text"><![CDATA[HTTP和HTTPS属于计算机网络范畴，但作为开发人员，不管是后台开发或是前台开发，都很有必要掌握它们。 网络层结构网络结构有两种主流的分层方式：OSI七层模型和TCP/IP四层模型。 OSI是指Open System Interconnect，意为开放式系统互联。 TCP/IP是指传输控制协议/网间协议，是目前世界上应用最广的协议 OSI层 对应TCP/IP层 OSI各层功能 网络协议 设备 应用层 应用层 应用程序（电子邮件，文件服务）,用户接口 HTTP，FTP，TFTP，NFS 网关 表示层 应用层 数据的表示，压缩和加密（数据格式化，代码转换，数据加密 TELNET，SNMP 网关 会话层 应用层 建立、管理和终止会话 SMTP，DNS 网关 传输层 传输层 OSI各层功能 TCP，UDP 网关 网络层 网际互联层 OSI各层功能 IP，ICMP，ARP，RARP，UUCP 路由器 链路层 网络接口层 OSI各层功能 FDDI，SLIP，PPP，PDN 交换机 物理层 网络接口层 OSI各层功能 ISO2110，IEEE802，IEEE802.2 集线器，中继器 两种模型区别 OSI采用七层模型，TCP/IP是四层模型 TCP/IP网络接口层没有真正的定义，只是概念性的描述。OSI把它分为2层，每一层功能详尽。 在协议开发之前，就有了OSI模型，所以OSI模型具有共通性，而TCP/IP是基于协议建立的模型，不适用于非TCP/IP的网络。 实际应用中，OSI模型是理论上的模型，没有成熟的产品；而TCP/IP已经成为国际标准。 HTTP协议HTTP是基于TCP/IP协议的应用程序协议，不包括数据包的传输，主要规定了客户端和服务器的通信格式，默认使用80端口。 HTTP协议的发展历史 1991年发布HTTP/0.9版本，只有Get命令，且服务端直返HTML格式字符串，服务器响应完毕就关闭TCP连接。 1996年发布HTTP/1.0版本，优点：可以发送任何格式内容，包括文字、图像、视频、二进制。也丰富了命令Get，Post，Head。请求和响应的格式加入头信息。缺点：每个TCP连接只能发送一个请求，而新建TCP连接的成本很高，导致HTTP/1.0新能很差。 1997发布HTTP/1.1版本，完善了HTTP协议，直至20年后的今天仍是最流行的版本。 优点： a. 引入持久连接，TCP默认不关闭，可被多个请求复用，对于一个域名，多数浏览器允许同时建立6个持久连接。 b. 引入管道机制，即在同一个TCP连接中，可以同时发送多个请求，不过服务器还是按顺序响应。 c. 在头部加入Content-Length字段，一个TCP可以同时传送多个响应，所以就需要该字段来区分哪些内容属于哪个响应。 d. 分块传输编码，对于耗时的动态操作，用流模式取代缓存模式，即产生一块数据，就发送一块数据。 e. 增加了许多命令，头信息增加Host来指定服务器域名，可以访问一台服务器上的不同网站。 缺点：TCP连接中的响应有顺序，服务器处理完一个回应才能处理下一个回应，如果某个回应特别慢，后面的请求就会排队等着（对头堵塞）。 2015年发布HTTP/2版本，它有几个特性：二进制协议、多工、数据流、头信息压缩、服务器推送。 HTTP请求和响应格式Request格式： 12345678GET /barite/account/stock/groups HTTP/1.1QUARTZ-SESSION: MC4xMDQ0NjA3NTI0Mzc0MjAyNg.VPXuA8rxTghcZlRCfiAwZlAIdCADEVICE-TYPE: ANDROIDAPI-VERSION: 15Host: shitouji.bluestonehk.comConnection: Keep-AliveAccept-Encoding: gzipUser-Agent: okhttp/3.10.0 Response格式： 123456789101112HTTP/1.1 200 OKServer: nginx/1.6.3Date: Mon, 15 Oct 2018 03:30:28 GMTContent-Type: application/json;charset=UTF-8Pragma: no-cacheCache-Control: no-cacheExpires: Thu, 01 Jan 1970 00:00:00 GMTContent-Encoding: gzipTransfer-Encoding: chunkedProxy-Connection: Keep-alive&#123;&quot;errno&quot;:0,&quot;dialogInfo&quot;:null,&quot;body&quot;:&#123;&quot;list&quot;:[&#123;&quot;flag&quot;:2,&quot;group_id&quot;:1557,&quot;group_name&quot;:&quot;港股&quot;,&quot;count&quot;:1&#125;,&#123;&quot;flag&quot;:3,&quot;group_id&quot;:1558,&quot;group_name&quot;:&quot;美股&quot;,&quot;count&quot;:7&#125;,&#123;&quot;flag&quot;:1,&quot;group_id&quot;:1556,&quot;group_name&quot;:&quot;全部&quot;,&quot;count&quot;:8&#125;]&#125;,&quot;message&quot;:&quot;success&quot;&#125; 说明一下请求头和响应头的部分字段： Host：指定服务器域名，可用来区分访问一个服务器上的不同服务 Connection：keep-alive表示要求服务器不要关闭TCP连接，close表示明确要求关闭连接，默认值是keep-alive Accept-Encoding：说明自己可以接收的压缩方式 User-Agent：用户代理，是服务器能识别客户端的操作系统（Android、IOS、WEB）及相关的信息。作用是帮助服务器区分客户端，并且针对不同客户端让用户看到不同数据，做不同操作。 Content-Type：服务器告诉客户端数据的格式，常见的值有text/plain，image/jpeg，image/png，video/mp4，application/json，application/zip。这些数据类型总称为MIME TYPE。 Content-Encoding：服务器数据压缩方式 Transfer-Encoding：chunked表示采用分块传输编码，有该字段则无需使用Content-Length字段。 Content-Length：声明数据的长度，请求和回应头部都可以使用该字段。 TCP三次握手HTTP和HTTPS协议请求时都会通过TCP三次握手建立TCP连接。那么，三次握手是指什么呢？ 那么，为什么一定要三次握手呢，一次可以吗？两次可以吗？ 带着这些问题，我们来分析一下为什么必须是三次握手。 第一次握手，A向B发送信息后，B收到信息。B可确认A的发信能力和B的收信能力 第二次握手，B向A发消息，A收到消息。A可确认A的发信能力和收信能力，A也可确认B的收信能力和发信能力 第三次握手，A向B发送消息，B接收到消息。B可确认A的收信能力和B的发信能力 通过三次握手，A和B都能确认自己和对方的收发信能力，相当于建立了互相的信任，就可以开始通信了。 下面，我们介绍一下三次握手具体发送的内容，用一张图描述如下： 首先，介绍一下几个概念： ACK：响应标识，1表示响应，连接建立成功之后，所有报文段ACK的值都为1 SYN：连接标识，1表示建立连接，连接请求和连接接受报文段- SYN=1，其他情况都是0 FIN：关闭连接标识，1标识关闭连接，关闭请求和关闭接受报文段- FIN=1，其他情况都是0，跟SYN类似 seq number：序号，一个随机数X，请求报文段中会有该字段，响应报文段没有 ack number：应答号，值为请求seq+1，即X+1，除了连接请求和连接接受响应报文段没有该字段，其他的报文段都有该字段 知道了上面几个概念后，看一下三次握手的具体流程： 第一次握手：建立连接请求。客户端发送连接请求报文段，将SYN置为1，seq为随机数x。然后，客户端进入SYN_SEND状态，等待服务器确认。 第二次握手：确认连接请求。服务器收到客户端的SYN报文段，需要对该请求进行确认，设置ack=x+1（即客户端seq+1）。同时自己也要发送SYN请求信息，即SYN置为1，seq=y。服务器将SYN和ACK信息放在一个报文段中，一并发送给客户端，服务器进入SYN_RECV状态。 第三次握手：客户端收到SYN+ACK报文段，将ack设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕，客户端和服务券进入ESTABLISHED状态，完成TCP三次握手。 从图中可以看出，建立连接经历了三次握手，当数据传输完毕，需要断开连接，而断开连接经历了四次挥手： 第一次挥手：主机1（可以是客户端或服务器），设置seq和ack向主机2发送一个FIN报文段，此时主机1进入FIN_WAIT_1状态，表示没有数据要发送给主机2了 第二次挥手：主机2收到主机1的FIN报文段，向主机1回应一个ACK报文段，表示同意关闭请求，主机1进入FIN_WAIT_2状态。 第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，主机2进入LAST_ACK状态。 第四次挥手：主机1收到主机2的FIN报文段，想主机2回应ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段后，关闭连接。此时主机1等待主机2一段时间后，没有收到回复，证明主机2已经正常关闭，主机1页关闭连接。 下面是TCP报文段首部格式图，对于理解TCP协议很重要： HTTPS协议/SSL协议HTTPS协议是以安全为目标的HTTP通道，简单来说就是HTTP的安全版。主要是在HTTP下加入SSL层（现在主流的是SLL/TLS），SSL是HTTPS协议的安全基础。HTTPS默认端口号为443。 HTTP存在的风险 窃听风险：HTTP采用明文传输数据，第三方可以获知通信内容 篡改风险：第三方可以修改通信内容 冒充风险：第三方可以冒充他人身份进行通信 SSL/TLS协议就是为了解决这些风险而设计，希望达到： 所有信息加密传输，三方窃听通信内容 具有校验机制，内容一旦被篡改，通信双发立刻会发现 配备身份证书，防止身份被冒充 下面主要介绍SSL/TLS协议。 SSL发展史（互联网加密通信） 1994年NetSpace公司设计SSL协议（Secure Sockets Layout）1.0版本，但未发布。 1995年NetSpace发布SSL/2.0版本，很快发现有严重漏洞 1996年发布SSL/3.0版本，得到大规模应用 1999年，发布了SSL升级版TLS/1.0版本，目前应用最广泛的版本 2006年和2008年，发布了TLS/1.1版本和TLS/1.2版本 SSL原理及运行过程SSL/TLS协议基本思路是采用公钥加密法（最有名的是RSA加密算法）。大概流程是，客户端向服务器索要公钥，然后用公钥加密信息，服务器收到密文，用自己的私钥解密。 为了防止公钥被篡改，把公钥放在数字证书中，证书可信则公钥可信。公钥加密计算量很大，为了提高效率，服务端和客户端都生成对话秘钥，用它加密信息，而对话秘钥是对称加密，速度非常快。而公钥用来机密对话秘钥。 下面用一张图表示SSL加密传输过程： 详细介绍一下图中过程： 1、客户端给出协议版本号、一个客户端随机数A（Client random）以及客户端支持的加密方式2、服务端确认双方使用的加密方式，并给出数字证书、一个服务器生成的随机数B（Server random）3、客户端确认数字证书有效，生成一个新的随机数C（Pre-master-secret），使用证书中的公钥对C加密，发送给服务端4、服务端使用自己的私钥解密出C5、客户端和服务器根据约定的加密方法，使用三个随机数ABC，生成对话秘钥，之后的通信都用这个对话秘钥进行加密。 SSL证书上面提到了，HTTPS协议中需要使用到SSL证书。 SSL证书是一个二进制文件，里面包含经过认证的网站公钥和一些元数据，需要从经销商购买。证书有很多类型，按认证级别分类： 域名认证（DV=Domain Validation）：最低级别的认证，可以确认申请人拥有这个域名 公司认证（OV=Organization Validation）：确认域名所有人是哪家公司，证书里面包含公司的信息 扩展认证（EV=Extended Validation）：最高级别认证，浏览器地址栏会显示公司名称。 按覆盖范围分类： 单域名证书：只能用于单域名，foo.com证书不能用不www.foo.com 通配符证书：可用于某个域名及所有一级子域名，比如*.foo.com的证书可用于foo.com，也可用于www.foo.com 多域名证书：可用于多个域名，比如foo.com和bar.com 认证级别越高，覆盖范围越广的证书，价格越贵。也有免费的证书，为了推广HTTPS，电子前哨基金会成立了Let’s Encrypt提供免费证书。 证书的经销商也很多，知名度比较高的有亚洲诚信(Trust Asia)。 RSA加密和DH加密加密算法分类加密算法分为对称加密、非对称加密和Hash加密算法。 对称加密：甲方和乙方使用同一种加密规则对信息加解密 非对称加密：乙方生成两把秘钥（公钥和私钥）。公钥是公开的，任何人都可以获取，私钥是保密的，只存在于乙方手中。甲方获取公钥，然后用公钥加密信息，乙方得到密文后，用私钥解密。 Hash加密：Hash算法是一种单向密码体制，即只有加密过程，没有解密过程 对称加密算法加解密效率高，速度快，适合大数据量加解密。常见的堆成加密算法有DES、AES、RC5、Blowfish、IDEA 非对称加密算法复杂，加解密速度慢，但安全性高，一般与对称加密结合使用（对称加密通信内容，非对称加密对称秘钥）。 常见的非对称加密算法有RSA、DH、DSA、ECC Hash算法特性是：输入值一样，经过哈希函数得到相同的散列值，但并非散列值相同则输入值也相同。常见的Hash加密算法有MD5、SHA-1、SHA-X系列 下面着重介绍一下RSA算法和DH算法。 RSA加密算法HTTPS协议就是使用RSA加密算法，可以说RSA加密算法是宇宙中最重要的加密算法。 RSA算法用到一些数论知识，包括互质关系，欧拉函数，欧拉定理。此处不具体介绍加密的过程，如果有兴趣，可以参照[RSA算法加密过程](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)。 RSA算法的安全保障基于大数分解问题，目前破解过的最大秘钥是700+位，也就代表1024位秘钥和2048位秘钥可以认为绝对安全。 大数分解主要难点在于计算能力，如果未来计算能力有了质的提升，那么这些秘钥也是有可能被破解的。 DH加密算法DH也是一种非对称加密算法，DH加密算法过程。 DH算法的安全保障是基于离散对数问题。 HTTP协议和HTTPS协议的对比HTTP和HTTPS的区别如下： HTTPS协议需要到CA申请证书，大多数情况下需要一定费用 HTTP是超文本传输协议，信息采用明文传输，HTTPS则是具有安全性SSL加密传输协议 HTTP和HTTPS端口号不一样，HTTP是80端口，HTTPS是443端口 HTTP连接是无状态的，而HTTPS采用HTTP+SSL构建可进行加密传输、身份认证的网络协议，更安全。 HTTP协议建立连接的过程比HTTPS协议快。因为HTTPS除了TCP三次握手，还要经过SSL握手。连接建立之后数据传输速度，二者无明显区别。 本文转发自作者：左大人链接：https://www.jianshu.com/p/27862635c077]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
        <tag>TCP</tag>
        <tag>RSA加密</tag>
        <tag>DH加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构与对象(6)——压缩列表]]></title>
    <url>%2F2019%2F02%2F12%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(6)%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[压缩列表压缩列表: (ziplist)是列表键(list)和哈希键(hash)的底层实现之一。当一个列表键只包含少量的列表项，并且每个列表项要么就是小整数值（具体见下文），要么就是长度比较短的字符串，那么Redis就会使用压缩列表来作为列表键的底层实现。注：Redis3.2分支引入了quicklist，并在4.0分支用quicklist替代了ziplist和linkedlist成为了列表对象的底层编码 redis&gt; RPUSH lst 1 3 5 10086 &quot;hello&quot; &quot;world&quot; &quot;6&quot; reids&gt; OBJECT ENCODING lst &quot;ziplist&quot; 另外，当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。 redis&gt; HMSET profile &quot;name&quot; &quot;Jack&quot; &quot;age&quot; 28 &quot;job&quot; &quot;Programmer&quot; &quot;OK&quot; reids&gt; OBJECT ENCODING profile &quot;ziplist&quot; 压缩列表的构成压缩列表顾名思义，是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结构。一个压缩列表可以包含任意多个节点(entry)，每个节点可以保存一个字节数组或一个整数值。 压缩列表的各个组成部分 zlbytes zltail zllen entry1 entry2 … entryN zlend 压缩列表各个组成部分详细说明 属性 类型 长度 用途 zlbytes uint32_t 4字节 记录整个压缩列表占用的内存字节数（即压缩列表总长），在对压缩列表进行内存重分配或计算zlend的位置时使用 zltail uint32_t 4字节 记录压缩列表表尾节点距离压缩列表的起始地址(即zlbytes的起始地址)有多少个字节，通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾节点（即最后一个entry）的地址 zllen uint16_t 2字节 记录了压缩列表包含的节点（即entry）数量，当这个属性的值小于UINT16_MAX(65535)时，这个属性的值就是压缩列表包含节点的数量，当这个值等于65535时，节点的真是数量需要遍历整个压缩列表才能计算得出 entryX 列表节点 不定 压缩列表包含的各个节点，节点的长度由节点保存的内容决定 zlend uint8_t 1字节 特殊值0xFF(十进制255)，用于标记压缩列表的末端 压缩列表节点的构成 previous_entry_length encoding content 每个压缩列表节点可以保存一个字节数组或者一个整数值，其中，字节数组可以是一下三种长度之一： 长度小于等于63（2^6-1)字节的字节数组 长度小于等于16383（2^14-1）字节的字节数组 长度小于等于4294967295（2^32-1）字节的字节数组而整数值则可以是一下六种长度之一： 4位长，介于0-12之间的无符号整数 1字节长的有符号整数 3字节长的有符号整数 int16_t类型整数 int32_t类型整数 int64_t类型整数 每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成。 previous_entry_length节点的previous_entry_length属性以字节位单位，记录了压缩列表中前一个节点的长度。previous_entry_length属性的长度可以是1字节或者5字节。 如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节，前一个节点的长度就保存在这一个字节中（如0x05，表示前一个节点为5字节） 如果前一个的长度大于254字节，那么previous_entry_length属性的长度为5字节，其中属性的第一字节会被设置为0xFE（十进制254），而之后的四个字节则用于保存前一节点的长度（如0xFE00002766，0x00002766十进制为10086，表示前一个节点长度为10086） 因为节点的previous_entry_length属性记录了前一个节点的长度，所以程序可以通过指针运算，根据当前的起始地址计算出前一个节点的起始地址。压缩列表的从表尾向表头遍历操作就是使用这一原理实现的。 encoding节点的encoding属性记录了节点的content属性所保存数据的类型以及长度 一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码，这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录 一字节长，值的最高位以11开头的是整数编码，这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录 字节数组编码 编码 编码长度 content属性保存的值 00xxxxxx 1字节 长度小于等于63字节的字节数组 01xxxxxx yyyyyyyy 2字节 长度小于等于16383字节的字节数组 10______ xxxxxxxx yyyyyyyy zzzzzzzz aaaaaaaa 5字节 长度小于等于4294967295字节的字节数组 整数编码 编码 编码长度 content属性保存的值 11000000 1字节 int16_t类型的整数 11010000 1字节 int32_t类型的整数 11100000 1字节 int64_t类型的整数 11110000 1字节 24位有符号整数 11111110 1字节 8位有符号整数 1111xxxx 1字节 使用这一编码的节点没有相应的content属性，因为编码本身的xxxx四个位已经保存了一个介于0-12的值，所以它无须content属性 content节点的content属性负责保存节点的值，节点值可以是一个字节数组或整数，值的类型和长度由节点的encoding属性决定。例如： previous_entry_length encoding content xxx 00001011 “hello world” 编码最高位00表示节点保存的是一个字节数组 编码后六位001011记录了字节数组长度为11 content属性保存了节点值字符串 连锁更新前面说过，每个节点的previous_entry_length属性都记录了前一个节点的长度，现在考虑这样一种情况，在一个压缩列表中，又多个连续的、长度介于250字节到253字节之间的节点e1至eN zlbytes zltail zllen entry1 entry2 … entryN zlend 因为e1至eN所有节点的长度都小于254字节，所以记录这些节点的长度只需要1字节长的previous_entry_length属性，这时，如果我们将一个长度大于等于254字节的新节点new设置为压缩列表的表头节点 zlbytes zltail zllen new-entry entry1 … entryN zlend 因为e1的previous_entry_length属性仅长1字节，无法保存新节点的长度，所以程序将对压缩列表执行空间重分配操作，并将e1节点的previous_entry_length属性从原来的1字节扩展为5字节。现在，问题来了，e1之前介于250字节到253字节，现在新增四个字节，e1长度必定大于254字节，因此e2也保存不下，得再次对压缩列表执行空间重分配操作，正如e1引发了e2的扩展，e2也会引发e3的扩展……直到eN为止。Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新(cascade)”，除了添加新节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新(如下，删除small节点，entry1会扩展为5字节）。 zlbytes zltail zllen big(大于254) small(小于254) entry1 … entryN zlend 因为连锁更新在最坏的情况下需要对压缩列表执行N次空间重分配操作，二每次空间重分配最坏的复杂度为O(N)(即从entry1开始分配)，所以连锁更新最坏复杂度为O(N^2)，即压缩列表的很多API最坏复杂度为O(N^2)，如ziplistPush等。但是尽管连锁更新的复杂度较高，但是可能性几率不大，或者节点数少也不会造成太大性能问题。 总结 压缩列表是一种为节约内存而开发的顺序性数据结构 压缩列表被用作列表键和哈希键的底层实现之一 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值 添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据结构</tag>
        <tag>ziplist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构与对象(5)——整数集合]]></title>
    <url>%2F2019%2F01%2F31%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(5)%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[整数集合整数集合: (intset)是集合键（set）的底层实现之一，当一个集合只包含整数值元素（浮点数会让set的object encoding 变成hashtable），并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。 redis&gt; SADD numbers 1 3 4 5 &quot;4&quot; reids&gt; OBJECT ENCODING numbers &quot;intset&quot; redis&gt; SADD numbers 1.1 &quot;1&quot; redis&gt; OBJECT ENCODING numbers &quot;hashtable&quot; 整数集合的实现整数集合是Redis用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t、int64_t的整数值，并且保证集合中不会出现重复元素。 整数集合:12345typedef struct intset &#123; uint32_t encoding; //编码方式 uint32_t length; //集合包含的元素数量 int8_t contents[]; //保存元素的数组&#125; intset; contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。虽然intset将contents属性声明为int8_t类型数组，但实际上contents数组并并不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值，即如果encoding属性的值为INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组，数组里每个元素占16位。 升级每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。升级并添加分为三步进行： 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变 将新元素添加到底层数组里面 举个例子：有一个INTSET_ENC_INT16编码的整数集合，集合中有1，2，3这三个int16_t的元素，底层数组的大小为3*16=48位。若把int32_t类型的65535添加到集合中，必须要对整个集合进行升级。首先要分配四个元素的空间，即36*4=128位。接下来把三个元素转换成int32_t类型，并放置到正确位上面，且维持有序性不变。最后将第四个元素加入，将整数集合encoding属性值从INTSET_ENC_INT16改为INTSET_ENC_INT32，并将length属性的值从3改为4。 因为每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已有的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N)。 升级的好处： 提升灵活性：因为C是静态类型语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面。但是，因为整数集合可以通过自动升级底层数组来适应新元素，所以我们可以随意将int16_t、int32_t、int64_t的整数添加到集合中，而不必担心出现类型错误 节约内存：当然，要让有一个数组可以同时保存int16_t、int32_t、int64_t的整数最简单的做法就是直接使用int64_t类型的数组作为整数集合的底层实现。不过这样一来会造成内存浪费的情况，而整数集合现在的做法既可以让集合能同时保存三种不同类型的值，又可以确保升级操作只会在有需要的时候进行，这可以尽量节省内存。 降级整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持在升级后的状态。 总结 整数集合是集合键的底层实现之一 整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型 升级操作为整数集合带来了操作上的灵活性，并且尽可能节约了内存 整数集合只支持升级操作，不支持降级操作]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据结构</tag>
        <tag>intset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构与对象(4)——跳跃表]]></title>
    <url>%2F2019%2F01%2F31%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(4)%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[跳跃表跳跃表: (skiplist)是一种有序的数据结构，支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。大部分情况下，跳跃表的效率可以和平衡树相媲美，且实现更为简单。Redis使用跳跃表作为有序集合键(zset)的底层实现之一，如果一个有序集合包含的元素数量较多，又或者有序集合中的元素成员(member)是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。 例如: fruit-price是一个有序集合键，这个有序集合以水果名为成员，水果价钱为分值，保存了130款水果的价钱 redis&gt; ZRANGE fruit-price 0 2 WITHSCORES 1)&quot;banana&quot; 2)&quot;5&quot; 3)&quot;cherry&quot; 4)&quot;6.5&quot; 5)&quot;apple&quot; 6)&quot;8&quot; redis&gt; ZCARD fruit-price (integer) 130 fruit-price有序集合的所有数据都保存在一个跳跃表里面，其中每个跳跃表节点(node)都保存了一款水果的价钱信息，所有水果按价钱的高低从低到高在跳跃表里面排序。 和链表、字典等数据结构被广泛地应用在Redis内部不一样，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外跳跃表在Redis中没有其他用途。 跳跃表原理性质: 由很多层结构组成； 每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点； 最底层的链表包含了所有的元素； 如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）； 链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点； 搜索: 其基本原理就是从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。 插入: 既然要插入，首先需要确定插入的层数，这里有不一样的方法。1. 抛硬币法，只要是正面就累加，直到遇见反面才停止，最后记录正面的次数并将其作为要添加新元素的层；2. 统计概率，先给定一个概率p，产生一个0到1之间的随机数，如果这个随机数小于p，则将高度加1，直到产生的随机数大于概率p才停止，根据给出的结论，当概率为1/2或者是1/4的时候，整体的性能会比较好（其实当p为1/2的时候，也就是抛硬币的方法）。 当确定好要插入的层数以后，则需要将元素都插入到从最底层到第k层。 删除: 在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。 跳跃表的实现Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如结点的数量，指向表头节点和表位节点的指针等等。 上图展示了一个跳跃表示例，位于图片最左边的是zskiplist结构，该结构包含以下属性： header：指向跳跃表的表头节点 tail：指向跳跃表的表尾节点 level：记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内) length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内) 位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性： 层(level)：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，依次类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。 后退(backward)指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。 分值(score)：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。 成员对象(obj)：各个节点中的o1、o2和o3是节点所保存的成员对象。 注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到，所以图中省略了这些部分，只显示了表头节点的各个层。 跳跃表节点:123456789typedef struct zskiplistNode &#123; struct zskiplistNode *backward; //后退指针 double score;//分值 robj *obj;//成员对象 struct zskiplistLevel &#123; //层 struct zskiplistNode *forward; //前进指针 unsigned int span; //跨度 &#125; level[];&#125; zskiplistNode; 层：跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。每次创建一个新跳跃表节点的时候，程序根据幂次定律(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。下图分别展示了三个高度为1层、3层和5层的节点，因为C语言的数组索引总是从0开始的，所以节点的第一层是level[0]，而第二层是level[1]，依次类推。 前进指针 跨度：层的跨度(level[i].span属性)用于记录两个节点之间的距离：两个节点之间的跨度越大，它们相距得就越远。指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样的，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位(rank)的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。 后退指针：节点的后退指针(backward属性)用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。 分值和成员：节点的分值(score属性)是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。节点的成员对象(obj属性)是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分至相同的节点将按照成员对象在字典中的大小来进行排序，成员对象较小的节点会排在前面(靠近表头的方向)，而成员对象较大的节点则会排在后面(靠近表尾的方向)。 跳跃表:12345typedef struct zskiplist &#123; struct zskiplistNode *header, *tail; //header指向跳跃表的表头节点，tail指向跳跃表的表尾节点 unsigned long length; //记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内) int level; //记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)&#125; zskiplist; header和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为O(1)。通过length属性，可以在O(1)复杂度内返回跳跃表的长度。level属性用于在O(1)复杂度内获取跳跃表中层高最大的那个节点的层数量（不计算表头节点的层高）。 总结 跳跃表是有序集合的底层实现之一 Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点 每个跳跃表节点的层高都是1至32之间的随机数 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象（指向SDS的一个指针）必须是唯一的 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象在字典序中的大小进行排序]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据结构</tag>
        <tag>跳跃表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构与对象(3)——字典]]></title>
    <url>%2F2019%2F01%2F31%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(3)%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[字典字典，又称为符号表(symbol table)、关联数组(associative array)或映射(map)，是一种用于保存键值对的抽象数据结构。字典中的每个键都是独一无二的，程序可以在字典中通过键查找与之关联的值，或进行更新删除等操作。Redis的数据库就是使用字典来作为底层实现的。例如： redis&gt;SET msg &quot;hello world&quot; OK 在数据库中创建了一个键为”msg”,值为”hello world”的键值对，保存在字典中。除了用来表示数据库外，字典还是哈希键的底层实现之一。 redis&gt; HMSET user name &quot;kendall&quot; sex &quot;man&quot; OK redis&gt; HGETALL user 1) &quot;name&quot; 2) &quot;kendall&quot; 3) &quot;sex&quot; 4) &quot;man&quot; user就是一个一个包含2个键值对的哈希键。 Redis的字典使用哈希表作为底层实现，一个哈希表可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。 哈希表:123456typedef struct dictht&#123; dictEntry **table; unsigned long size; unsigned long sizemask;//哈希表大小掩码，总是等于size-1，用于计算索引值 unsigned long used;&#125;dictht; table是一个数组，数组中的每一个元素都是一个指向dictEntry结构的指针，每个dictEntry结构都保存着一个键值对。123456789typedef struct dictEntry&#123; void key; union&#123; void *val; uint64_t u64; int64_t s64; &#125;v; struct dictEntry *next;//哈希冲突时，采用链表法解决&#125;dictEntry; 字典:123456typedef struct dict&#123; dictType *type;//类型特定函数 void *privdata;//私有数据 dictht ht[2];//哈希表 int trehashidx;//rehash索引，当rehash不进行时，为-1；&#125;dict; 了解：type属性是指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，privdate保存了传给那些函数的可选参数。 ht是一个长度为2的数组，包含了两个dictht哈希表。一般情况下字典只使用ht[0]哈希表，ht[1]只有在进行rehash的时候使用。rehashidx记录了rehash的进度。 哈希算法: 当要将一个新的键值对添加到字典时，程序需要先根据键值对的键计算出哈希值和索引值，然后根据索引值将节点放到韩系标书组的指定索引上面。Redis使用MurmurHash2算法来计算哈希值(Redis v3.0)。12hash = dict-&gt;type-&gt;hashFunction(key);index = hash &amp; dict-&gt;ht[x].sizemask; 解决键冲突当有两个或以上数量的键被分配到了哈希表数组的同一个索引上时，我们称这些键发生了冲突。Redis的哈希表使用了链地址法解决键冲突，每个哈希表节点都由一个next指针，被分配到同一个索引上的节点可以用next连接成单向链表，新加入的节点总是排在所有节点的前面。 扩容（收缩）和rehash哈希表的键值对会逐渐的增加或减少，为了让哈希表的负载因子(load factor)，维持在一个合理的范围，程序需要对哈希表进行相应的扩容或收缩。当满足以下两点任意一点时，扩容开始。当满足负载因子小于0.1时，进行收缩。 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5 其中负载因子计算方法为： load_factor = ht[0].used/dictht.size 步骤如下： 为字典的ht[1]分配空间，如果执行的是扩展操作，那么ht[1]的大小为大于等于ht[0].used*2的最小2^n；若是收缩操作，那么ht[1]的大小为大于等于ht[0].used的最小2^n。 将保存在ht[0]中的所有键值对rehash（重新计算键的哈希和索引）到ht[1]上，并将键值对放置到ht[1]。 当ht[0]的所有键值对都迁移到了ht[1]上后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新建一个空白的哈希表，为下一次rehash做准备。 Redis的rehash时渐进式的，即不是一次性、集中式完成的，而是分多次完成。这样做是避免键值对过多时，庞大的计算量导致服务器停止服务。渐进式的步骤如下： 为ht[1]分配空间 在字典中维持rehashidx,将其值设置为0，表示rehash正式开始 在rehash期间，每次对字典的增删查改，程序都会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成后，rehashidx增加1 随着字典操作不断执行，最终某个时间上，ht[0]的所有键值对都会被rehash至ht[1],rehashidx设为-1，代表rehash完成。 rehash过程中，字典会同时使用两个哈希表，如ht[0]没找到，会继续去ht[1]找。而添加一律会被保存在ht[1]。 举例: set msg HelloWorld这个命令执行以后，redis会在dict-&gt;ht-&gt;dictht-&gt;table中加入一个dictEntry，entry的位置由dict内置的hash算法(比如MurmurHash2)与大小掩码作与运算得出，这个dictEntry包含了key-value和next属性，key和value是redis的SDS简单动态字符串的抽象类。 总结 字典被广泛用于实现Redis（远程字典服务）的各种功能，其中包括数据库和哈希键。 Redis中的字典使用哈希表作为底层实现，每个字典待优两个哈希表，一个平时使用，另一个仅在进行rehash时使用 Redis目前使用MurmurHash2算法计算键的哈希值 哈希表使用链地址法来解决冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表 在对哈希表进行扩展或收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程不是一次性完完成的，而是伴随着每一次增删改查渐进式完成的]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据结构</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构与对象(2)——链表]]></title>
    <url>%2F2019%2F01%2F31%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(2)%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表链表提供了高效的节点重排能力，以及顺序性节点的访问方式，并且可以通过增删节点来灵活地调整长度。Redis中的列表键(list)的底层实现之一就是链表。当一个链表键包含了较多元素，又或者列表中包含的元素都是较长的字符串时，Redis就会使用链表作为列表键的底层实现。（实际上链表还被广泛用于实现Redis的各种功能，比如发布与订阅、慢查询、监视器等） redis&gt;LLEN integers (integer) 1024 redis&gt;LRANGE integers 0 3 1)&quot;1&quot; 2)&quot;2&quot; 3)&quot;3&quot; integers列表键底层实现就是一个链表，每个节点都保存了一个整数值。 Redis链表的实现: 每个链表节点都包含了指向prev和next的两个指针，同时还有保存节点值的value指针。12345typedef struct listNode&#123; struct listNode *prev; struct listNode *next; void *value;&#125;listNode; Redis list结构: list结构为链表提供了表头指针，表尾指针，以及链表长度计数器len，这么做的好处是获取prev和next节点、获取head和tail节点、获取链表长度的时间复杂度均为O(1)。此外还提供了三个特定函数。12345678typedef struct list&#123; listNode *head; listNode *tail; unsigned long len; void *(*dup)(void *ptr); void *(*free)(void *ptr); int *(*match)(void *ptr,void *key);&#125;list;]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构与对象(1)——简单动态字符串SDS]]></title>
    <url>%2F2018%2F12%2F28%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(1)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS%2F</url>
    <content type="text"><![CDATA[简单动态字符串-SDSRedis是由C语言编写的，但Redis没有直接使用C语言传统的字符串表示，而是自己构建了一种叫做简单动态字符串（simple dynamic string, SDS）的抽象类型，除了用来保存字符串外，SDS还被用作缓冲区，如AOF缓冲区。当你在redis客户端执行命令： redis&gt;SET msg &quot;hello world&quot; OK 那么Redis将会创建一个新的键值对，而这个键值对的键”msg”和键值对的值”hello world”底层实现就是保存了字符串的SDS。 SDS定义: struct sdshdr{ int len; //记录buf数组中已使用的字节的数量 int free; //记录buf数组中未使用的字节的数量 char buf[]; //保存字符串char的数组 } SDS的结构其实就是一个字节数组，如字符串”redis”，那么buf就是一个保存了[‘r’,’e’,’d’,’i’,’s’,’\0’]的char数组（’\0’是C语言的一个惯例，redis遵守这个惯例是为了直接重用C库里的一些字符串函数） 为什么要用SDS？C语言使用的字符串方式，并不能满足Redis对字符串安全性、效率以及功能的要求。 常数复杂度获取字符串长度：C获取字符串长度复杂度为O(N)，而SDS保存了len属性，获取字符串长度复杂度为O(1) 杜绝缓冲区溢出：C字符串不记录自身长度带来的另一个问题就是容易造成缓冲区溢出，例如内存中紧邻的s1-“redis”和s2-“mongo”，如果此时执行strcat(s1,&quot;cluster&quot;)，且没有在此之前为s1分配足够的空间，那么s2保存的内容将被意外的修改。与C不同，当SDS的API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需，不满足的话，API会自动将SDS的空间扩展至所需修改的大小，然后再进行实际的修改，所以SDS不需要手动修改SDS的空间大小，也不会出现缓冲区溢出问题。 减少修改字符串时带来的内存重分配次数：C在每次进行字符串修改时（增长或缩短），总要进行一次内存重分配操作，而内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以比较耗时。为了避免这个缺陷，SDS通过未使用空间接触字符串长度和底层数组长度的关联。buf的数组长度可能包含未使用的字节，由free属性记录。实际上SDS用未使用空间实现了两种优化策略。3.1 空间预分配：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须的空间，还会分配额外的未使用空间。若修改后的SDS长度（len属性）小于1MB，那么分配和len属性同样大小的未使用空间，即buf的实际长度为len+len+1byte;若长度大于1MB，那么程序会分配1MB的未使用空间，即buf的实际长度为lne+1MB+1byte。3.2 惰性空间释放：执行字符串缩短操作后，SDS并不会立即释放多余的空间，而是保留作为未使用空间，以减少内存重分配操作，并未将来可能的增长提供优化。当然SDS也提供主动释放空间的API。 二进制安全：C以”\0”为结尾标记，若有使用此特殊字符的字符串，则无法用C字符串保存。而SDS虽然保留了C以”\0”结尾的惯例，但并不以此来识别字符串是否结束，可以说数据在写入SDS是什么样的，它被读取出来就是什么样的。因此二进制安全的SDS可以保存任意格式的二进制数据。 兼容部分的C字符串函数]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据结构</tag>
        <tag>SDS</tag>
      </tags>
  </entry>
</search>
