<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis数据结构与对象(5)——整数集合]]></title>
    <url>%2F2019%2F01%2F31%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(5)%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[1.5 整数集合整数集合: (intset)是集合键（set）的底层实现之一，当一个集合只包含整数值元素（浮点数会让set的object encoding 变成hashtable），并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。 redis&gt; SADD numbers 1 3 4 5 &quot;4&quot; reids&gt; OBJECT ENCODING numbers &quot;intset&quot; redis&gt; SADD numbers 1.1 &quot;1&quot; redis&gt; OBJECT ENCODING numbers &quot;hashtable&quot; Redis使用跳跃表作为有序集合键(zset)的底层实现之一，如果一个有序集合包含的元素数量较多，又或者有序集合中的元素成员(member)是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。 例如: fruit-price是一个有序集合键，这个有序集合以水果名为成员，水果价钱为分值，保存了130款水果的价钱 redis&gt; ZRANGE fruit-price 0 2 WITHSCORES 1)&quot;banana&quot; 2)&quot;5&quot; 3)&quot;cherry&quot; 4)&quot;6.5&quot; 5)&quot;apple&quot; 6)&quot;8&quot; redis&gt; ZCARD fruit-price (integer) 130 整数集合的实现整数集合是Redis用于保存整数值的集合抽象数据结构，可以保存类型为int16_t、int32_t、int64_t的整数值，并且保证集合中不会出现重复元素。 整数集合:12345typedef struct intset &#123; uint32_t encoding; //编码方式 uint32_t length; //集合包含的元素数量 int8_t contents[]; //保存元素的数组&#125; intset; contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。虽然intset将contents属性声明为int8_t类型数组，但实际上contents数组并并不保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值，即如果encoding属性的值为INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组，数组里每个元素占16位。 升级每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。升级并添加分为三步进行： 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变 将新元素添加到底层数组里面 举个例子：有一个INTSET_ENC_INT16编码的整数集合，集合中有1，2，3这三个int16_t的元素，底层数组的大小为3*16=48位。若把int32_t类型的65535添加到集合中，必须要对整个集合进行升级。首先要分配四个元素的空间，即36*4=128位。接下来把三个元素转换成int32_t类型，并放置到正确位上面，且维持有序性不变。最后将第四个元素加入，将整数集合encoding属性值从INTSET_ENC_INT16改为INTSET_ENC_INT32，并将length属性的值从3改为4。 因为每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已有的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O(N)。 升级的好处： 提升灵活性：因为C是静态类型语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面。但是，因为整数集合可以通过自动升级底层数组来适应新元素，所以我们可以随意将int16_t、int32_t、int64_t的整数添加到集合中，而不必担心出现类型错误 节约内存：当然，要让有一个数组可以同时保存int16_t、int32_t、int64_t的整数最简单的做法就是直接使用int64_t类型的数组作为整数集合的底层实现。不过这样一来会造成内存浪费的情况，而整数集合现在的做法既可以让集合能同时保存三种不同类型的值，又可以确保升级操作只会在有需要的时候进行，这可以尽量节省内存。 降级整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持在升级后的状态。 总结 整数集合是集合键的底层实现之一 整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型 升级操作为整数集合带来了操作上的灵活性，并且尽可能节约了内存 整数集合只支持升级操作，不支持降级操作]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据结构</tag>
        <tag>intset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构与对象(4)——跳跃表]]></title>
    <url>%2F2019%2F01%2F31%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(4)%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.4 跳跃表跳跃表: (skiplist)是一种有序的数据结构，支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。大部分情况下，跳跃表的效率可以和平衡树相媲美，且实现更为简单。Redis使用跳跃表作为有序集合键(zset)的底层实现之一，如果一个有序集合包含的元素数量较多，又或者有序集合中的元素成员(member)是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。 例如: fruit-price是一个有序集合键，这个有序集合以水果名为成员，水果价钱为分值，保存了130款水果的价钱 redis&gt; ZRANGE fruit-price 0 2 WITHSCORES 1)&quot;banana&quot; 2)&quot;5&quot; 3)&quot;cherry&quot; 4)&quot;6.5&quot; 5)&quot;apple&quot; 6)&quot;8&quot; redis&gt; ZCARD fruit-price (integer) 130 fruit-price有序集合的所有数据都保存在一个跳跃表里面，其中每个跳跃表节点(node)都保存了一款水果的价钱信息，所有水果按价钱的高低从低到高在跳跃表里面排序。 和链表、字典等数据结构被广泛地应用在Redis内部不一样，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外跳跃表在Redis中没有其他用途。 跳跃表原理性质: 由很多层结构组成； 每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点； 最底层的链表包含了所有的元素； 如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）； 链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点； 搜索: 其基本原理就是从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。 插入: 既然要插入，首先需要确定插入的层数，这里有不一样的方法。1. 抛硬币法，只要是正面就累加，直到遇见反面才停止，最后记录正面的次数并将其作为要添加新元素的层；2. 统计概率，先给定一个概率p，产生一个0到1之间的随机数，如果这个随机数小于p，则将高度加1，直到产生的随机数大于概率p才停止，根据给出的结论，当概率为1/2或者是1/4的时候，整体的性能会比较好（其实当p为1/2的时候，也就是抛硬币的方法）。 当确定好要插入的层数以后，则需要将元素都插入到从最底层到第k层。 删除: 在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。 跳跃表的实现Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如结点的数量，指向表头节点和表位节点的指针等等。 上图展示了一个跳跃表示例，位于图片最左边的是zskiplist结构，该结构包含以下属性： header：指向跳跃表的表头节点 tail：指向跳跃表的表尾节点 level：记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内) length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内) 位于zskiplist结构右方的是四个zskiplistNode结构，该结构包含以下属性： 层(level)：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，依次类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。 后退(backward)指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。 分值(score)：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。 成员对象(obj)：各个节点中的o1、o2和o3是节点所保存的成员对象。 注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到，所以图中省略了这些部分，只显示了表头节点的各个层。 跳跃表节点:123456789typedef struct zskiplistNode &#123; struct zskiplistNode *backward; //后退指针 double score;//分值 robj *obj;//成员对象 struct zskiplistLevel &#123; //层 struct zskiplistNode *forward; //前进指针 unsigned int span; //跨度 &#125; level[];&#125; zskiplistNode; 层：跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。每次创建一个新跳跃表节点的时候，程序根据幂次定律(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。下图分别展示了三个高度为1层、3层和5层的节点，因为C语言的数组索引总是从0开始的，所以节点的第一层是level[0]，而第二层是level[1]，依次类推。 前进指针 跨度：层的跨度(level[i].span属性)用于记录两个节点之间的距离：两个节点之间的跨度越大，它们相距得就越远。指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样的，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位(rank)的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。 后退指针：节点的后退指针(backward属性)用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。 分值和成员：节点的分值(score属性)是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。节点的成员对象(obj属性)是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分至相同的节点将按照成员对象在字典中的大小来进行排序，成员对象较小的节点会排在前面(靠近表头的方向)，而成员对象较大的节点则会排在后面(靠近表尾的方向)。 跳跃表:12345typedef struct zskiplist &#123; struct zskiplistNode *header, *tail; //header指向跳跃表的表头节点，tail指向跳跃表的表尾节点 unsigned long length; //记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内) int level; //记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)&#125; zskiplist; header和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为O(1)。通过length属性，可以在O(1)复杂度内返回跳跃表的长度。level属性用于在O(1)复杂度内获取跳跃表中层高最大的那个节点的层数量（不计算表头节点的层高）。 总结 跳跃表是有序集合的底层实现之一 Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点 每个跳跃表节点的层高都是1至32之间的随机数 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象（指向SDS的一个指针）必须是唯一的 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象在字典序中的大小进行排序]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据结构</tag>
        <tag>跳跃表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构与对象(3)——字典]]></title>
    <url>%2F2019%2F01%2F31%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(3)%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[1.3 字典字典，又称为符号表(symbol table)、关联数组(associative array)或映射(map)，是一种用于保存键值对的抽象数据结构。字典中的每个键都是独一无二的，程序可以在字典中通过键查找与之关联的值，或进行更新删除等操作。Redis的数据库就是使用字典来作为底层实现的。例如： redis&gt;SET msg &quot;hello world&quot; OK 在数据库中创建了一个键为”msg”,值为”hello world”的键值对，保存在字典中。除了用来表示数据库外，字典还是哈希键的底层实现之一。 redis&gt; HMSET user name &quot;kendall&quot; sex &quot;man&quot; OK redis&gt; HGETALL user 1) &quot;name&quot; 2) &quot;kendall&quot; 3) &quot;sex&quot; 4) &quot;man&quot; user就是一个一个包含2个键值对的哈希键。 Redis的字典使用哈希表作为底层实现，一个哈希表可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。 哈希表:123456typedef struct dictht&#123; dictEntry **table; unsigned long size; unsigned long sizemask;//哈希表大小掩码，总是等于size-1，用于计算索引值 unsigned long used;&#125;dictht; table是一个数组，数组中的每一个元素都是一个指向dictEntry结构的指针，每个dictEntry结构都保存着一个键值对。123456789typedef struct dictEntry&#123; void key; union&#123; void *val; uint64_t u64; int64_t s64; &#125;v; struct dictEntry *next;//哈希冲突时，采用链表法解决&#125;dictEntry; 字典:123456typedef struct dict&#123; dictType *type;//类型特定函数 void *privdata;//私有数据 dictht ht[2];//哈希表 int trehashidx;//rehash索引，当rehash不进行时，为-1；&#125;dict; 了解：type属性是指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，privdate保存了传给那些函数的可选参数。 ht是一个长度为2的数组，包含了两个dictht哈希表。一般情况下字典只使用ht[0]哈希表，ht[1]只有在进行rehash的时候使用。rehashidx记录了rehash的进度。 哈希算法: 当要将一个新的键值对添加到字典时，程序需要先根据键值对的键计算出哈希值和索引值，然后根据索引值将节点放到韩系标书组的指定索引上面。Redis使用MurmurHash2算法来计算哈希值(Redis v3.0)。12hash = dict-&gt;type-&gt;hashFunction(key);index = hash &amp; dict-&gt;ht[x].sizemask; 解决键冲突当有两个或以上数量的键被分配到了哈希表数组的同一个索引上时，我们称这些键发生了冲突。Redis的哈希表使用了链地址法解决键冲突，每个哈希表节点都由一个next指针，被分配到同一个索引上的节点可以用next连接成单向链表，新加入的节点总是排在所有节点的前面。 扩容（收缩）和rehash哈希表的键值对会逐渐的增加或减少，为了让哈希表的负载因子(load factor)，维持在一个合理的范围，程序需要对哈希表进行相应的扩容或收缩。当满足以下两点任意一点时，扩容开始。当满足负载因子小于0.1时，进行收缩。 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5 其中负载因子计算方法为： load_factor = ht[0].used/dictht.size 步骤如下： 为字典的ht[1]分配空间，如果执行的是扩展操作，那么ht[1]的大小为大于等于ht[0].used*2的最小2^n；若是收缩操作，那么ht[1]的大小为大于等于ht[0].used的最小2^n。 将保存在ht[0]中的所有键值对rehash（重新计算键的哈希和索引）到ht[1]上，并将键值对放置到ht[1]。 当ht[0]的所有键值对都迁移到了ht[1]上后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新建一个空白的哈希表，为下一次rehash做准备。 Redis的rehash时渐进式的，即不是一次性、集中式完成的，而是分多次完成。这样做是避免键值对过多时，庞大的计算量导致服务器停止服务。渐进式的步骤如下： 为ht[1]分配空间 在字典中维持rehashidx,将其值设置为0，表示rehash正式开始 在rehash期间，每次对字典的增删查改，程序都会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成后，rehashidx增加1 随着字典操作不断执行，最终某个时间上，ht[0]的所有键值对都会被rehash至ht[1],rehashidx设为-1，代表rehash完成。 rehash过程中，字典会同时使用两个哈希表，如ht[0]没找到，会继续去ht[1]找。而添加一律会被保存在ht[1]。 举例: set msg HelloWorld这个命令执行以后，redis会在dict-&gt;ht-&gt;dictht-&gt;table中加入一个dictEntry，entry的位置由dict内置的hash算法(比如MurmurHash2)与大小掩码作与运算得出，这个dictEntry包含了key-value和next属性，key和value是redis的SDS简单动态字符串的抽象类。 总结 字典被广泛用于实现Redis（远程字典服务）的各种功能，其中包括数据库和哈希键。 Redis中的字典使用哈希表作为底层实现，每个字典待优两个哈希表，一个平时使用，另一个仅在进行rehash时使用 Redis目前使用MurmurHash2算法计算键的哈希值 哈希表使用链地址法来解决冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表 在对哈希表进行扩展或收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程不是一次性完完成的，而是伴随着每一次增删改查渐进式完成的]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据结构</tag>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构与对象二]]></title>
    <url>%2F2019%2F01%2F31%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(2)%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表链表提供了高效的节点重排能力，以及顺序性节点的访问方式，并且可以通过增删节点来灵活地调整长度。Redis中的列表键(list)的底层实现之一就是链表。当一个链表键包含了较多元素，又或者列表中包含的元素都是较长的字符串时，Redis就会使用链表作为列表键的底层实现。（实际上链表还被广泛用于实现Redis的各种功能，比如发布与订阅、慢查询、监视器等） redis&gt;LLEN integers (integer) 1024 redis&gt;LRANGE integers 0 3 1)&quot;1&quot; 2)&quot;2&quot; 3)&quot;3&quot; integers列表键底层实现就是一个链表，每个节点都保存了一个整数值。 Redis链表的实现: 每个链表节点都包含了指向prev和next的两个指针，同时还有保存节点值的value指针。12345typedef struct listNode&#123; struct listNode *prev; struct listNode *next; void *value;&#125;listNode; Redis list结构: list结构为链表提供了表头指针，表尾指针，以及链表长度计数器len，这么做的好处是获取prev和next节点、获取head和tail节点、获取链表长度的时间复杂度均为O(1)。此外还提供了三个特定函数。12345678typedef struct list&#123; listNode *head; listNode *tail; unsigned long len; void *(*dup)(void *ptr); void *(*free)(void *ptr); int *(*match)(void *ptr,void *key);&#125;list;]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构与对象（一）——简单动态字符串SDS]]></title>
    <url>%2F2018%2F12%2F28%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(1)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS%2F</url>
    <content type="text"><![CDATA[1 简单动态字符串-SDSRedis是由C语言编写的，但Redis没有直接使用C语言传统的字符串表示，而是自己构建了一种叫做简单动态字符串（simple dynamic string, SDS）的抽象类型，除了用来保存字符串外，SDS还被用作缓冲区，如AOF缓冲区。当你在redis客户端执行命令： redis&gt;SET msg &quot;hello world&quot; OK 那么Redis将会创建一个新的键值对，而这个键值对的键”msg”和键值对的值”hello world”底层实现就是保存了字符串的SDS。 SDS定义: struct sdshdr{ int len; //记录buf数组中已使用的字节的数量 int free; //记录buf数组中未使用的字节的数量 char buf[]; //保存字符串char的数组 } SDS的结构其实就是一个字节数组，如字符串”redis”，那么buf就是一个保存了[‘r’,’e’,’d’,’i’,’s’,’\0’]的char数组（’\0’是C语言的一个惯例，redis遵守这个惯例是为了直接重用C库里的一些字符串函数） 为什么要用SDS？C语言使用的字符串方式，并不能满足Redis对字符串安全性、效率以及功能的要求。 常数复杂度获取字符串长度：C获取字符串长度复杂度为O(N)，而SDS保存了len属性，获取字符串长度复杂度为O(1) 杜绝缓冲区溢出：C字符串不记录自身长度带来的另一个问题就是容易造成缓冲区溢出，例如内存中紧邻的s1-“redis”和s2-“mongo”，如果此时执行strcat(s1,&quot;cluster&quot;)，且没有在此之前为s1分配足够的空间，那么s2保存的内容将被意外的修改。与C不同，当SDS的API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需，不满足的话，API会自动将SDS的空间扩展至所需修改的大小，然后再进行实际的修改，所以SDS不需要手动修改SDS的空间大小，也不会出现缓冲区溢出问题。 减少修改字符串时带来的内存重分配次数：C在每次进行字符串修改时（增长或缩短），总要进行一次内存重分配操作，而内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以比较耗时。为了避免这个缺陷，SDS通过未使用空间接触字符串长度和底层数组长度的关联。buf的数组长度可能包含未使用的字节，由free属性记录。实际上SDS用未使用空间实现了两种优化策略。3.1 空间预分配：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须的空间，还会分配额外的未使用空间。若修改后的SDS长度（len属性）小于1MB，那么分配和len属性同样大小的未使用空间，即buf的实际长度为len+len+1byte;若长度大于1MB，那么程序会分配1MB的未使用空间，即buf的实际长度为lne+1MB+1byte。3.2 惰性空间释放：执行字符串缩短操作后，SDS并不会立即释放多余的空间，而是保留作为未使用空间，以减少内存重分配操作，并未将来可能的增长提供优化。当然SDS也提供主动释放空间的API。 二进制安全：C以”\0”为结尾标记，若有使用此特殊字符的字符串，则无法用C字符串保存。而SDS虽然保留了C以”\0”结尾的惯例，但并不以此来识别字符串是否结束，可以说数据在写入SDS是什么样的，它被读取出来就是什么样的。因此二进制安全的SDS可以保存任意格式的二进制数据。 兼容部分的C字符串函数]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据结构</tag>
        <tag>SDS</tag>
      </tags>
  </entry>
</search>
