<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>D&#39;blog</title>
  
  <subtitle>Java Developer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pudgedd.github.io/"/>
  <updated>2019-03-18T15:00:13.985Z</updated>
  <id>https://pudgedd.github.io/</id>
  
  <author>
    <name>Kendall Luo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis数据结构与对象(7)——quicklist</title>
    <link href="https://pudgedd.github.io/2019/03/18/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(7)%E2%80%94%E2%80%94quicklist/"/>
    <id>https://pudgedd.github.io/2019/03/18/Redis数据结构与对象(7)——quicklist/</id>
    <published>2019-03-18T09:08:02.000Z</published>
    <updated>2019-03-18T15:00:13.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><p>Redis3.2分支以后引入了一种新的内部数据结构——<code>quicklist</code>，<code>quicklist</code>经常被用作<strong>列表键</strong>的实现之一，4.0版本以后取消了<strong>列表键对象</strong>的<code>ziplist</code>和<code>linkedlist</code>编码，统一使用<code>quicklist</code>编码。<br><a id="more"></a></p><pre><code>redis&gt; RPUSH lst 1 3 5 10086 &quot;hello&quot; &quot;world&quot;&quot;6&quot;reids&gt; OBJECT ENCODING lst&quot;quicklist&quot;</code></pre><h3 id="quicklist的构成"><a href="#quicklist的构成" class="headerlink" title="quicklist的构成"></a>quicklist的构成</h3><p>Redis4.0版本以后用自定义的一种复杂数据结构<code>quicklist</code>取代了<code>ziplsit</code>和<code>linkedlist</code>，它本身是一个<strong>双向无环链表</strong>，它的每一个节点都是一个<code>ziplist</code>，可以看出<code>quicklist</code>其实是将<code>ziplist</code>和<code>linkedlist</code>结合到了一个数据结构中。为什么这么设计呢？</p><ul><li>链表在插入，删除节点的时间复杂度很低；但是内存利用率低，且由于内存不连续容易产生内存碎片</li><li>压缩表内存连续，存储效率高；但是插入和删除的成本太高，需要频繁的进行数据搬移、释放或申请内存（每次数据变动都会引发一次内存的realloc。特别是当<code>ziplist</code>长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能）。</li></ul><p>而<code>quicklist</code>通过将每个压缩表用双向链表的方式连接起来，来寻求一种收益最大化。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>首先是<code>quicklist</code>的节点<code>quicklistNode</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;  <span class="comment">// ziplist</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">// ziplist的内存大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">// zpilist中数据项的个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">// 1为ziplist 2是LZF压缩存储方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>;   <span class="comment">// 压缩标志, 为1 是压缩</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">// 节点是否能够被压缩,只用在测试</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure><p><code>quicklistNode</code>实际上就是对<code>ziplist</code>的进一步封装，其中包括：</p><ul><li><code>prev</code>: 指向链表前一个节点的指针。</li><li><code>next</code>: 指向链表后一个节点的指针。<br>zl: 数据指针。如果当前节点的数据没有压缩，那么它指向一个<code>ziplist</code>结构；否则，它指向一个<code>quicklistLZF</code>结构。</li><li><code>sz</code>: 表示<code>zl</code>指向的<code>ziplist</code>的总大小（包括<code>zlbytes</code>, <code>zltail</code>, <code>zllen</code>, <code>zlend</code>和各个数据项）。需要注意的是：如果<code>ziplist</code>被压缩了，那么这个<code>sz</code>的值仍然是压缩前的<code>ziplist</code>大小。</li><li><code>count</code>: 表示<code>ziplist</code>里面包含的数据项个数。这个字段只有16bit。稍后我们会一起计算一下这16bit是否够用。</li><li><code>encoding</code>: 表示<code>ziplist</code>是否压缩了（以及用了哪个压缩算法）。目前只有两种取值：2表示被压缩了（而且用的是LZF压缩算法），1表示没有压缩。</li><li><code>container</code>: 是一个预留字段。本来设计是用来表明一个<code>quicklist</code>节点下面是直接存数据，还是使用<code>ziplist</code>存数据，或者用其它的结构来存数据（用作一个数据容器，所以叫<code>container</code>）。但是，在目前的实现中，这个值是一个固定的值2，表示使用<code>ziplist</code>作为数据容器。</li><li><code>recompress</code>: 当我们使用类似<code>lindex</code>这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置<code>recompress=1</code>做一个标记，等有机会再把数据重新压缩。</li><li><code>attempted_compress</code>: 这个值只对Redis的自动化测试程序有用。我们不用管它。</li><li><code>extra</code>: 其它扩展字段。目前Redis的实现里也没用上。</li></ul><p><code>quicklistLZF</code>结构表示一个被压缩过的<code>ziplist</code>。其中：</p><ul><li><code>sz</code>: 表示压缩后的<code>ziplist</code>大小。</li><li><code>compressed</code>: 是个柔性数组（flexible array member），存放压缩后的<code>ziplist</code>字节数组。</li></ul><p><code>quicklist</code>: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;    <span class="comment">// 头结点</span></span><br><span class="line">    quicklistNode *tail;    <span class="comment">// 尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;    <span class="comment">// 所有数据的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;       <span class="comment">// quicklist节点数量</span></span><br><span class="line">    <span class="keyword">int</span> fill : <span class="number">16</span>;          <span class="comment">// 单个ziplist的大小限制</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>;   <span class="comment">// 压缩深度</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure><p>真正表示<code>quicklist</code>的数据结构是同名的<code>quicklist</code>这个struct：</p><ul><li><code>head</code>: 指向头节点（左侧第一个节点）的指针。</li><li><code>tail</code>: 指向尾节点（右侧第一个节点）的指针。</li><li><code>count</code>: 所有<code>ziplist</code>数据项的个数总和。</li><li><code>len</code>: <code>quicklist</code>节点的个数。</li><li><code>fill</code>: 16bit，<code>ziplist</code>大小设置，存放<code>list-max-ziplist-size</code>参数的值。</li><li><code>compress</code>: 16bit，节点压缩深度设置，存放<code>list-compress-depth</code>参数的值。</li></ul><h3 id="quicklistNode的大小"><a href="#quicklistNode的大小" class="headerlink" title="quicklistNode的大小"></a>quicklistNode的大小</h3><p>到底一个<code>quicklistNode</code>节点包含多长的<code>ziplist</code>合适呢？比如，同样是存储12个数据项，既可以是一个<code>quicklist</code>包含3个节点，而每个节点的<code>ziplist</code>又包含4个数据项，也可以是一个<code>quicklist</code>包含6个节点，而每个节点的<code>ziplist</code>又包含2个数据项。</p><p>这又是一个需要找平衡点的难题。我们只从存储效率上分析一下：</p><ul><li>每个<code>quicklist</code>节点上的<code>ziplist</code>越短，则内存碎片越多。内存碎片多了，有可能在内存中产生很多无法被利用的小碎片，从而降低存储效率。这种情况的极端是每个<code>quicklist</code>节点上的<code>ziplist</code>只包含一个数据项，这就蜕化成一个普通的双向链表了。</li><li>每个<code>quicklist</code>节点上的<code>ziplist</code>越长，则为<code>ziplist</code>分配大块连续内存空间的难度就越大。有可能出现内存里有很多小块的空闲空间（它们加起来很多），但却找不到一块足够大的空闲空间分配给<code>ziplist</code>的情况。这同样会降低存储效率。这种情况的极端是整个<code>quicklist</code>只有一个节点，所有的数据项都分配在这仅有的一个节点的<code>ziplist</code>里面。这其实蜕化成一个<code>ziplist</code>了。</li></ul><p>可见，一个<code>quicklist</code>节点上的<code>ziplist</code>要保持一个合理的长度。那到底多长合理呢？这可能取决于具体应用场景。实际上，Redis提供了一个配置参数<code>list-max-ziplist-size</code>，就是为了让使用者可以来根据自己的情况进行调整。</p><pre><code>list-max-ziplist-size -2</code></pre><p>我们来详细解释一下这个参数的含义。它可以取正值，也可以取负值。</p><p>当取<strong>正值</strong>的时候，表示<strong>按照数据项个数</strong>来限定每个<code>quicklist</code>节点上的<code>ziplist</code>长度。比如，当这个参数配置成5的时候，表示每个<code>quicklist</code>节点的<code>ziplist</code>最多包含5个数据项。当取<strong>负值</strong>的时候，表示<strong>按照占用字节数</strong>来限定每个<code>quicklist</code>节点上的<code>ziplist</code>长度。这时，它只能取-1到-5这五个值，每个值含义如下：</p><ul><li>-5: 每个<code>quicklist</code>节点上的<code>ziplist</code>大小不能超过64 Kb。（注：1kb =&gt; 1024 bytes）</li><li>-4: 每个<code>quicklist</code>节点上的<code>ziplist</code>大小不能超过32 Kb。</li><li>-3: 每个<code>quicklist</code>节点上的<code>ziplist</code>大小不能超过16 Kb。</li><li>-2: 每个<code>quicklist</code>节点上的<code>ziplist</code>大小不能超过8 Kb。（<strong>-2是Redis给出的默认值</strong>）</li><li>-1: 每个<code>quicklist</code>节点上的<code>ziplist</code>大小不能超过4 Kb。</li><li>为正数时，表示单个节点最大允许的元素个数，最大为32768个</li></ul><p>当列表很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率比较低（访问起来性能也很低）。如果应用场景符合这个特点，那么list还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。Redis的配置参数list-compress-depth就是用来完成这个设置的。</p><pre><code>list-compress-depth 0</code></pre><p>这个参数表示一个<code>quicklist</code>两端<strong>不被压缩</strong>的节点个数。注：这里的节点个数是指<code>quicklist</code>双向链表的节点个数，而不是指<code>ziplist</code>里面的数据项个数。实际上，一个<code>quicklist</code>节点上的<code>ziplist</code>，如果被压缩，就是整体被压缩的。</p><p>参数<code>list-compress-depth</code>的取值含义如下：</p><ul><li>0: 是个特殊值，表示<strong>都不压缩</strong>。这是Redis的<strong>默认值</strong>。</li><li>1: 表示<code>quicklist</code>两端各有1个节点不压缩，中间的节点压缩。</li><li>2: 表示<code>quicklist</code>两端各有2个节点不压缩，中间的节点压缩。</li><li>3: 表示<code>quicklist</code>两端各有3个节点不压缩，中间的节点压缩。<br>依此类推…</li><li>由于0是个特殊值，很容易看出<code>quicklist</code>的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取。</li></ul><p>Redis对于<code>quicklist</code>内部节点的压缩算法，采用的<code>LZF</code>——<strong>一种无损压缩算法</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>quicklist</code>除了常用的增删改查外还提供了merge、将<code>ziplist</code>转换为<code>quicklist</code>等API</li><li><code>quicklist</code>是Redis3.2分支后在<code>ziplist</code>和<code>linkedlist</code>两种数据结构的基础上融合而成的一个实用的复杂数据结构</li><li><code>quicklist</code>在4.0之后取代了<code>linkedlist</code>和<code>ziplist</code>作为list的基础数据类型</li><li><code>quicklist</code>的大部分API都是直接复用<code>ziplist</code></li><li><code>quicklist</code>的单个节点最大存储默认为8kb</li><li><code>quicklist</code>提供了基于LZF算法的压缩API，通过将不常用的中间节点数据压缩达到节省内存的目的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;quicklist&quot;&gt;&lt;a href=&quot;#quicklist&quot; class=&quot;headerlink&quot; title=&quot;quicklist&quot;&gt;&lt;/a&gt;quicklist&lt;/h2&gt;&lt;p&gt;Redis3.2分支以后引入了一种新的内部数据结构——&lt;code&gt;quicklist&lt;/code&gt;，&lt;code&gt;quicklist&lt;/code&gt;经常被用作&lt;strong&gt;列表键&lt;/strong&gt;的实现之一，4.0版本以后取消了&lt;strong&gt;列表键对象&lt;/strong&gt;的&lt;code&gt;ziplist&lt;/code&gt;和&lt;code&gt;linkedlist&lt;/code&gt;编码，统一使用&lt;code&gt;quicklist&lt;/code&gt;编码。&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://pudgedd.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://pudgedd.github.io/tags/Redis/"/>
    
      <category term="数据结构" scheme="https://pudgedd.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="quicklist" scheme="https://pudgedd.github.io/tags/quicklist/"/>
    
  </entry>
  
  <entry>
    <title>HTTP和HTTPS</title>
    <link href="https://pudgedd.github.io/2019/02/20/HTTP%E5%92%8CHTTPS/"/>
    <id>https://pudgedd.github.io/2019/02/20/HTTP和HTTPS/</id>
    <published>2019-02-20T06:02:19.000Z</published>
    <updated>2019-02-25T06:39:23.877Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.techalyst.com/content/uploads/editor-photos/blog/1ecaab6c899ab15bc9aabf9533060047d17ddbf3.png" class="full-image"><br>HTTP和HTTPS属于计算机网络范畴，但作为开发人员，不管是后台开发或是前台开发，都很有必要掌握它们。<br><a id="more"></a></p><h2 id="网络层结构"><a href="#网络层结构" class="headerlink" title="网络层结构"></a>网络层结构</h2><p>网络结构有两种主流的分层方式：<strong>OSI七层模型和TCP/IP四层模型。</strong></p><p>OSI是指Open System Interconnect，意为开放式系统互联。</p><p>TCP/IP是指传输控制协议/网间协议，是目前世界上应用最广的协议</p><table><thead><tr><th>OSI层</th><th>对应TCP/IP层</th><th>OSI各层功能</th><th>网络协议</th><th>设备</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>应用程序（电子邮件，文件服务）,用户接口</td><td>HTTP，FTP，TFTP，NFS</td><td>网关</td></tr><tr><td>表示层</td><td>应用层</td><td>数据的表示，压缩和加密（数据格式化，代码转换，数据加密</td><td>TELNET，SNMP</td><td>网关</td></tr><tr><td>会话层</td><td>应用层</td><td>建立、管理和终止会话</td><td>SMTP，DNS</td><td>网关</td></tr><tr><td>传输层</td><td>传输层</td><td>OSI各层功能</td><td>TCP，UDP</td><td>网关</td></tr><tr><td>网络层</td><td>网际互联层</td><td>OSI各层功能</td><td>IP，ICMP，ARP，RARP，UUCP</td><td>路由器</td></tr><tr><td>链路层</td><td>网络接口层</td><td>OSI各层功能</td><td>FDDI，SLIP，PPP，PDN</td><td>交换机</td></tr><tr><td>物理层</td><td>网络接口层</td><td>OSI各层功能</td><td>ISO2110，IEEE802，IEEE802.2</td><td>集线器，中继器</td></tr></tbody></table><h3 id="两种模型区别"><a href="#两种模型区别" class="headerlink" title="两种模型区别"></a>两种模型区别</h3><ol><li>OSI采用七层模型，TCP/IP是四层模型</li><li>TCP/IP网络接口层没有真正的定义，只是概念性的描述。OSI把它分为2层，每一层功能详尽。</li><li>在协议开发之前，就有了OSI模型，所以OSI模型具有共通性，而TCP/IP是基于协议建立的模型，不适用于非TCP/IP的网络。</li><li>实际应用中，OSI模型是理论上的模型，没有成熟的产品；而TCP/IP已经成为国际标准。</li></ol><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP是基于TCP/IP协议的<strong>应用程序协议</strong>，不包括数据包的传输，主要规定了客户端和服务器的通信格式，默认使用80端口。</p><h3 id="HTTP协议的发展历史"><a href="#HTTP协议的发展历史" class="headerlink" title="HTTP协议的发展历史"></a>HTTP协议的发展历史</h3><ol><li>1991年发布HTTP/0.9版本，只有Get命令，且服务端直返HTML格式字符串，服务器响应完毕就关闭TCP连接。</li><li>1996年发布HTTP/1.0版本，优点：可以发送任何格式内容，包括文字、图像、视频、二进制。也丰富了命令Get，Post，Head。请求和响应的格式加入头信息。缺点：每个TCP连接只能发送一个请求，而新建TCP连接的成本很高，导致HTTP/1.0新能很差。</li><li>1997发布HTTP/1.1版本，完善了HTTP协议，直至20年后的今天仍是最流行的版本。</li></ol><ul><li>优点：<ul><li>a. 引入持久连接，TCP默认不关闭，可被多个请求复用，对于一个域名，多数浏览器允许同时建立6个持久连接。</li><li>b. 引入管道机制，即在同一个TCP连接中，可以同时发送多个请求，不过服务器还是按顺序响应。</li><li>c. 在头部加入Content-Length字段，一个TCP可以同时传送多个响应，所以就需要该字段来区分哪些内容属于哪个响应。</li><li>d. 分块传输编码，对于耗时的动态操作，用流模式取代缓存模式，即产生一块数据，就发送一块数据。</li><li>e. 增加了许多命令，头信息增加Host来指定服务器域名，可以访问一台服务器上的不同网站。</li></ul></li><li>缺点：TCP连接中的响应有顺序，服务器处理完一个回应才能处理下一个回应，如果某个回应特别慢，后面的请求就会排队等着（对头堵塞）。</li></ul><ol start="4"><li>2015年发布HTTP/2版本，它有几个特性：二进制协议、多工、数据流、头信息压缩、服务器推送。</li></ol><h3 id="HTTP请求和响应格式"><a href="#HTTP请求和响应格式" class="headerlink" title="HTTP请求和响应格式"></a>HTTP请求和响应格式</h3><p>Request格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /barite/account/stock/groups HTTP/1.1</span><br><span class="line">QUARTZ-SESSION: MC4xMDQ0NjA3NTI0Mzc0MjAyNg.VPXuA8rxTghcZlRCfiAwZlAIdCA</span><br><span class="line">DEVICE-TYPE: ANDROID</span><br><span class="line">API-VERSION: 15</span><br><span class="line">Host: shitouji.bluestonehk.com</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">User-Agent: okhttp/3.10.0</span><br></pre></td></tr></table></figure><p>Response格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.6.3</span><br><span class="line">Date: Mon, 15 Oct 2018 03:30:28 GMT</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Expires: Thu, 01 Jan 1970 00:00:00 GMT</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Proxy-Connection: Keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;errno&quot;:0,&quot;dialogInfo&quot;:null,&quot;body&quot;:&#123;&quot;list&quot;:[&#123;&quot;flag&quot;:2,&quot;group_id&quot;:1557,&quot;group_name&quot;:&quot;港股&quot;,&quot;count&quot;:1&#125;,&#123;&quot;flag&quot;:3,&quot;group_id&quot;:1558,&quot;group_name&quot;:&quot;美股&quot;,&quot;count&quot;:7&#125;,&#123;&quot;flag&quot;:1,&quot;group_id&quot;:1556,&quot;group_name&quot;:&quot;全部&quot;,&quot;count&quot;:8&#125;]&#125;,&quot;message&quot;:&quot;success&quot;&#125;</span><br></pre></td></tr></table></figure><p>说明一下请求头和响应头的部分字段：</p><ul><li><code>Host</code>：指定服务器域名，可用来区分访问一个服务器上的不同服务</li><li><code>Connection</code>：keep-alive表示要求服务器不要关闭TCP连接，close表示明确要求关闭连接，默认值是keep-alive</li><li><code>Accept-Encoding</code>：说明自己可以接收的压缩方式</li><li><code>User-Agent</code>：用户代理，是服务器能识别客户端的操作系统（Android、IOS、WEB）及相关的信息。作用是帮助服务器区分客户端，并且针对不同客户端让用户看到不同数据，做不同操作。</li><li><code>Content-Type</code>：服务器告诉客户端数据的格式，常见的值有text/plain，image/jpeg，image/png，video/mp4，application/json，application/zip。这些数据类型总称为MIME TYPE。</li><li><code>Content-Encoding</code>：服务器数据压缩方式</li><li><code>Transfer-Encoding</code>：chunked表示采用分块传输编码，有该字段则无需使用Content-Length字段。</li><li><code>Content-Length</code>：声明数据的长度，请求和回应头部都可以使用该字段。</li></ul><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>HTTP和HTTPS协议请求时都会通过<strong>TCP三次握手建立TCP连接</strong>。那么，三次握手是指什么呢？</p><p><img src="https://upload-images.jianshu.io/upload_images/9942787-afa31b861fb0f247.png?imageMogr2/auto-orient/" alt="TCP三次握手"></p><p><strong>那么，为什么一定要三次握手呢，一次可以吗？两次可以吗？</strong></p><p>带着这些问题，我们来分析一下为什么必须是三次握手。</p><ol><li>第一次握手，A向B发送信息后，B收到信息。B可确认A的发信能力和B的收信能力</li><li>第二次握手，B向A发消息，A收到消息。A可确认A的发信能力和收信能力，A也可确认B的收信能力和发信能力</li><li>第三次握手，A向B发送消息，B接收到消息。B可确认A的收信能力和B的发信能力</li></ol><p>通过三次握手，A和B都能确认自己和对方的收发信能力，相当于建立了互相的信任，就可以开始通信了。</p><p>下面，我们介绍一下三次握手具体发送的内容，用一张图描述如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/9942787-495afdbac8f2012c.png?imageMogr2/auto-orient/" alt="三次握手"></p><p>首先，介绍一下几个概念：</p><ul><li><code>ACK</code>：响应标识，1表示响应，连接建立成功之后，所有报文段ACK的值都为1</li><li><code>SYN</code>：连接标识，1表示建立连接，连接请求和连接接受报文段- SYN=1，其他情况都是0</li><li><code>FIN</code>：关闭连接标识，1标识关闭连接，关闭请求和关闭接受报文段- FIN=1，其他情况都是0，跟SYN类似</li><li><code>seq number</code>：序号，一个随机数X，请求报文段中会有该字段，响应报文段没有</li><li><code>ack number</code>：应答号，值为请求seq+1，即X+1，除了连接请求和连接接受响应报文段没有该字段，其他的报文段都有该字段</li></ul><p>知道了上面几个概念后，看一下三次握手的具体流程：</p><ol><li><strong>第一次握手</strong>：建立连接请求。客户端发送连接请求报文段，将SYN置为1，seq为随机数x。然后，客户端进入SYN_SEND状态，等待服务器确认。</li><li><strong>第二次握手</strong>：确认连接请求。服务器收到客户端的SYN报文段，需要对该请求进行确认，设置ack=x+1（即客户端seq+1）。同时自己也要发送SYN请求信息，即SYN置为1，seq=y。服务器将SYN和ACK信息放在一个报文段中，一并发送给客户端，服务器进入SYN_RECV状态。</li><li><strong>第三次握手</strong>：客户端收到SYN+ACK报文段，将ack设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕，客户端和服务券进入ESTABLISHED状态，完成TCP三次握手。</li></ol><p>从图中可以看出，建立连接经历了三次握手，当数据传输完毕，需要断开连接，而<strong>断开连接经历了四次挥手</strong>：</p><ol><li><strong>第一次挥</strong>手：主机1（可以是客户端或服务器），设置seq和ack向主机2发送一个FIN报文段，此时主机1进入FIN_WAIT_1状态，表示没有数据要发送给主机2了</li><li><strong>第二次挥手</strong>：主机2收到主机1的FIN报文段，向主机1回应一个ACK报文段，表示同意关闭请求，主机1进入FIN_WAIT_2状态。</li><li><strong>第三次挥手</strong>：主机2向主机1发送FIN报文段，请求关闭连接，主机2进入LAST_ACK状态。</li><li><strong>第四次挥手</strong>：主机1收到主机2的FIN报文段，想主机2回应ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段后，关闭连接。此时主机1等待主机2一段时间后，没有收到回复，证明主机2已经正常关闭，主机1页关闭连接。</li></ol><p>下面是<strong>TCP报文段首部</strong>格式图，对于理解TCP协议很重要：</p><p><img src="https://s1.ax1x.com/2018/03/02/9rzlJf.png" alt="TCP报文段首部"></p><h2 id="HTTPS协议-SSL协议"><a href="#HTTPS协议-SSL协议" class="headerlink" title="HTTPS协议/SSL协议"></a>HTTPS协议/SSL协议</h2><p>HTTPS协议是以安全为目标的HTTP通道，简单来说就是HTTP的安全版。主要是<strong>在HTTP下加入SSL层（现在主流的是SLL/TLS）</strong>，SSL是HTTPS协议的安全基础。HTTPS默认端口号为443。</p><h3 id="HTTP存在的风险"><a href="#HTTP存在的风险" class="headerlink" title="HTTP存在的风险"></a>HTTP存在的风险</h3><ol><li><strong>窃听风险</strong>：HTTP采用明文传输数据，第三方可以获知通信内容</li><li><strong>篡改风险</strong>：第三方可以修改通信内容</li><li><strong>冒充风险</strong>：第三方可以冒充他人身份进行通信</li></ol><p>SSL/TLS协议就是为了解决这些风险而设计，希望达到：</p><ol><li>所有信息加密传输，三方窃听通信内容</li><li>具有校验机制，内容一旦被篡改，通信双发立刻会发现</li><li>配备身份证书，防止身份被冒充</li></ol><p>下面主要介绍SSL/TLS协议。</p><h3 id="SSL发展史（互联网加密通信）"><a href="#SSL发展史（互联网加密通信）" class="headerlink" title="SSL发展史（互联网加密通信）"></a>SSL发展史（互联网加密通信）</h3><ol><li>1994年NetSpace公司设计SSL协议（Secure Sockets Layout）1.0版本，但未发布。</li><li>1995年NetSpace发布SSL/2.0版本，很快发现有严重漏洞</li><li>1996年发布SSL/3.0版本，得到大规模应用</li><li>1999年，发布了SSL升级版TLS/1.0版本，目前应用最广泛的版本</li><li>2006年和2008年，发布了TLS/1.1版本和TLS/1.2版本</li></ol><h3 id="SSL原理及运行过程"><a href="#SSL原理及运行过程" class="headerlink" title="SSL原理及运行过程"></a>SSL原理及运行过程</h3><p>SSL/TLS协议基本思路是采用<strong>公钥加密法</strong>（最有名的是<strong>RSA加密算法</strong>）。大概流程是，<strong>客户端向服务器索要公钥，然后用公钥加密信息，服务器收到密文，用自己的私钥解密</strong>。</p><p>为了防止公钥被篡改，把公钥放在数字证书中，证书可信则公钥可信。公钥加密计算量很大，为了提高效率，服务端和客户端都生成对话秘钥，用它加密信息，而对话秘钥是对称加密，速度非常快。而公钥用来机密对话秘钥。</p><p>下面用一张图表示<strong>SSL加密传输过程</strong>：</p><p><img src="https://www.google.com/url?sa=i&amp;source=images&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwj55MXP4MngAhUL5oMKHbE6BZkQjRx6BAgBEAU&amp;url=%2Furl%3Fsa%3Di%26source%3Dimages%26cd%3D%26ved%3D%26url%3Dhttp%253A%252F%252Fwww.ruanyifeng.com%252Fblog%252F2014%252F09%252Fillustration-ssl.html%26psig%3DAOvVaw33EPMiWfIQcIHROr2xlzUq%26ust%3D1550732941970451&amp;psig=AOvVaw33EPMiWfIQcIHROr2xlzUq&amp;ust=1550732941970451" alt="SSL加密传输过程"></p><p>详细介绍一下图中过程：</p><p>1、客户端给出协议版本号、一个客户端随机数A（Client random）以及客户端支持的加密方式<br>2、服务端确认双方使用的加密方式，并给出数字证书、一个服务器生成的随机数B（Server random）<br>3、客户端确认数字证书有效，生成一个新的随机数C（Pre-master-secret），使用证书中的公钥对C加密，发送给服务端<br>4、服务端使用自己的私钥解密出C<br>5、客户端和服务器根据约定的加密方法，使用三个随机数ABC，生成对话秘钥，之后的通信都用这个对话秘钥进行加密。</p><h3 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h3><p>上面提到了，HTTPS协议中需要使用到SSL证书。</p><p>SSL证书是一个二进制文件，里面包含经过认证的网站公钥和一些元数据，需要从经销商购买。<br>证书有很多类型，按认证级别分类：</p><ul><li><strong>域名认证（DV=Domain Validation）</strong>：最低级别的认证，可以确认申请人拥有这个域名</li><li><strong>公司认证（OV=Organization Validation）</strong>：确认域名所有人是哪家公司，证书里面包含公司的信息</li><li><strong>扩展认证（EV=Extended Validation）</strong>：最高级别认证，浏览器地址栏会显示公司名称。</li></ul><p>按覆盖范围分类：</p><ul><li>单域名证书：只能用于单域名，foo.com证书不能用不<a href="http://www.foo.com" target="_blank" rel="noopener">www.foo.com</a></li><li>通配符证书：可用于某个域名及所有一级子域名，比如*.foo.com的证书可用于foo.com，也可用于<a href="http://www.foo.com" target="_blank" rel="noopener">www.foo.com</a></li><li>多域名证书：可用于多个域名，比如foo.com和bar.com</li></ul><p>认证级别越高，覆盖范围越广的证书，价格越贵。也有免费的证书，为了推广HTTPS，电子前哨基金会成立了Let’s Encrypt提供免费证书。</p><p>证书的经销商也很多，知名度比较高的有亚洲诚信(Trust Asia)。</p><h2 id="RSA加密和DH加密"><a href="#RSA加密和DH加密" class="headerlink" title="RSA加密和DH加密"></a>RSA加密和DH加密</h2><h3 id="加密算法分类"><a href="#加密算法分类" class="headerlink" title="加密算法分类"></a>加密算法分类</h3><p>加密算法分为<strong>对称加密</strong>、<strong>非对称加密</strong>和<strong>Hash加密算法</strong>。</p><ul><li><strong>对称加密</strong>：甲方和乙方使用同一种加密规则对信息加解密</li><li><strong>非对称加密</strong>：乙方生成两把秘钥（公钥和私钥）。公钥是公开的，任何人都可以获取，私钥是保密的，只存在于乙方手中。甲方获取公钥，然后用公钥加密信息，乙方得到密文后，用私钥解密。</li><li><strong>Hash加</strong>密：Hash算法是一种单向密码体制，即只有加密过程，没有解密过程</li></ul><p>对称加密算法加解密效率高，速度快，适合大数据量加解密。常见的堆成加密算法有DES、AES、RC5、Blowfish、IDEA</p><p>非对称加密算法复杂，加解密速度慢，但安全性高，一般与对称加密结合使用（对称加密通信内容，非对称加密对称秘钥）。</p><p>常见的非对称加密算法有<code>RSA</code>、<code>DH</code>、<code>DSA</code>、<code>ECC</code></p><p>Hash算法特性是：输入值一样，经过哈希函数得到相同的散列值，但并非散列值相同则输入值也相同。常见的Hash加密算法有MD5、SHA-1、SHA-X系列</p><p>下面着重介绍一下RSA算法和DH算法。</p><h4 id="RSA加密算法"><a href="#RSA加密算法" class="headerlink" title="RSA加密算法"></a>RSA加密算法</h4><p>HTTPS协议就是使用RSA加密算法，可以说RSA加密算法是宇宙中最重要的加密算法。</p><p>RSA算法用到一些数论知识，包括互质关系，欧拉函数，欧拉定理。此处不具体介绍加密的过程，如果有兴趣，可以参照[RSA算法加密过程]<br>(<a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)。" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)。</a></p><p>RSA算法的安全保障基于大数分解问题，目前破解过的最大秘钥是700+位，也就代表1024位秘钥和2048位秘钥可以认为绝对安全。</p><p>大数分解主要难点在于计算能力，如果未来计算能力有了质的提升，那么这些秘钥也是有可能被破解的。</p><h4 id="DH加密算法"><a href="#DH加密算法" class="headerlink" title="DH加密算法"></a>DH加密算法</h4><p>DH也是一种非对称加密算法，<a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="noopener">DH加密算法过程</a>。</p><p>DH算法的安全保障是基于离散对数问题。</p><h2 id="HTTP协议和HTTPS协议的对比"><a href="#HTTP协议和HTTPS协议的对比" class="headerlink" title="HTTP协议和HTTPS协议的对比"></a>HTTP协议和HTTPS协议的对比</h2><p>HTTP和HTTPS的<strong>区别</strong>如下：</p><ol><li>HTTPS协议需要到CA申请证书，大多数情况下需要一定费用</li><li>HTTP是超文本传输协议，信息采用明文传输，HTTPS则是具有安全性SSL加密传输协议</li><li>HTTP和HTTPS端口号不一样，HTTP是80端口，HTTPS是443端口</li><li>HTTP连接是无状态的，而HTTPS采用HTTP+SSL构建可进行加密传输、身份认证的网络协议，更安全。</li><li>HTTP协议建立连接的过程比HTTPS协议快。因为HTTPS除了TCP三次握手，还要经过SSL握手。连接建立之后数据传输速度，二者无明显区别。</li></ol><blockquote><p>本文转发自<br>作者：左大人<br>链接：<a href="https://www.jianshu.com/p/27862635c077" target="_blank" rel="noopener">https://www.jianshu.com/p/27862635c077</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.techalyst.com/content/uploads/editor-photos/blog/1ecaab6c899ab15bc9aabf9533060047d17ddbf3.png&quot; class=&quot;full-image&quot;&gt;&lt;br&gt;HTTP和HTTPS属于计算机网络范畴，但作为开发人员，不管是后台开发或是前台开发，都很有必要掌握它们。&lt;br&gt;
    
    </summary>
    
      <category term="网络" scheme="https://pudgedd.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="https://pudgedd.github.io/tags/HTTP/"/>
    
      <category term="HTTPS" scheme="https://pudgedd.github.io/tags/HTTPS/"/>
    
      <category term="TCP" scheme="https://pudgedd.github.io/tags/TCP/"/>
    
      <category term="RSA加密" scheme="https://pudgedd.github.io/tags/RSA%E5%8A%A0%E5%AF%86/"/>
    
      <category term="DH加密" scheme="https://pudgedd.github.io/tags/DH%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构与对象(6)——压缩列表</title>
    <link href="https://pudgedd.github.io/2019/02/12/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(6)%E2%80%94%E2%80%94%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/"/>
    <id>https://pudgedd.github.io/2019/02/12/Redis数据结构与对象(6)——压缩列表/</id>
    <published>2019-02-12T05:52:41.000Z</published>
    <updated>2019-03-18T15:02:00.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表<br>: (ziplist)是<strong>列表键(list)</strong>和<strong>哈希键(hash)</strong>的底层实现之一。当一个列表键只包含少量的列表项，并且每个列表项要么就是小整数值（具体见下文），要么就是长度比较短的字符串，那么Redis就会使用压缩列表来作为列表键的底层实现。(Redis3.2分支引入了<a href="&quot;https://pudgedd.github.io/2019/03/18/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(7">quicklist</a>%E2%80%94%E2%80%94quicklist/“)，并在4.0分支用<code>quicklist</code>替代了<code>ziplist</code>和<code>linkedlist</code>成为了列表对象的底层编码)<br><a id="more"></a></p><pre><code>redis&gt; RPUSH lst 1 3 5 10086 &quot;hello&quot; &quot;world&quot;&quot;6&quot;reids&gt; OBJECT ENCODING lst&quot;ziplist&quot;</code></pre><p>另外，当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。</p><pre><code>redis&gt; HMSET profile &quot;name&quot; &quot;Jack&quot; &quot;age&quot; 28 &quot;job&quot; &quot;Programmer&quot;&quot;OK&quot;reids&gt; OBJECT ENCODING profile&quot;ziplist&quot;</code></pre><h3 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h3><p>压缩列表顾名思义，是Redis为了节约内存而开发的，是<strong>由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结构</strong>。一个压缩列表可以包含任意多个<strong>节点(entry)</strong>，每个节点可以保存<strong>一个字节数组或一个整数值</strong>。</p><p>压缩列表的各个组成部分</p><table><thead><tr><th>zlbytes</th><th>zltail</th><th>zllen</th><th>entry1</th><th>entry2</th><th>…</th><th>entryN</th><th>zlend</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>压缩列表各个组成部分详细说明</p><table><thead><tr><th>属性</th><th>类型</th><th>长度</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td>zlbytes</td><td>uint32_t</td><td>4字节</td><td style="text-align:left">记录整个压缩列表占用的内存字节数（即压缩列表总长），在对压缩列表进行内存重分配或计算zlend的位置时使用</td></tr><tr><td>zltail</td><td>uint32_t</td><td>4字节</td><td style="text-align:left">记录压缩列表表尾节点距离压缩列表的起始地址(即zlbytes的起始地址)有多少个字节，通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾节点（即最后一个entry）的地址</td></tr><tr><td>zllen</td><td>uint16_t</td><td>2字节</td><td style="text-align:left">记录了压缩列表包含的节点（即entry）数量，当这个属性的值小于UINT16_MAX(65535)时，这个属性的值就是压缩列表包含节点的数量，当这个值等于65535时，节点的真是数量需要遍历整个压缩列表才能计算得出</td></tr><tr><td>entryX</td><td>列表节点</td><td>不定</td><td style="text-align:left">压缩列表包含的各个节点，节点的长度由节点保存的内容决定</td></tr><tr><td>zlend</td><td>uint8_t</td><td>1字节</td><td style="text-align:left">特殊值0xFF(十进制255)，用于标记压缩列表的末端</td></tr></tbody></table><h3 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h3><table><thead><tr><th>previous_entry_length</th><th>encoding</th><th>content</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>每个压缩列表<strong>节点</strong>可以保存一个<strong>字节数组</strong>或者一个<strong>整数值</strong>，其中，字节数组可以是一下三种长度之一：</p><ul><li>长度小于等于63（2^6-1)字节的字节数组</li><li>长度小于等于16383（2^14-1）字节的字节数组</li><li>长度小于等于4294967295（2^32-1）字节的字节数组<br>而整数值则可以是一下六种长度之一：</li><li>4位长，介于0-12之间的无符号整数</li><li>1字节长的有符号整数</li><li>3字节长的有符号整数</li><li>int16_t类型整数</li><li>int32_t类型整数</li><li>int64_t类型整数</li></ul><p>每个压缩列表节点都由<code>previous_entry_length</code>、<code>encoding</code>、<code>content</code>三个部分组成。</p><h4 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h4><p>节点的<code>previous_entry_length</code>属性以字节位单位，记录了压缩列表中前一个节点的长度。<code>previous_entry_length</code>属性的长度可以是<strong>1字节</strong>或者<strong>5字节</strong>。</p><ul><li>如果前一节点的长度小于254字节，那么<code>previous_entry_length</code>属性的长度为1字节，前一个节点的长度就保存在这一个字节中（如0x05，表示前一个节点为5字节）</li><li>如果前一个的长度大于254字节，那么<code>previous_entry_length</code>属性的长度为5字节，其中属性的第一字节会被设置为0xFE（十进制254），而之后的四个字节则用于保存前一节点的长度（如0xFE00002766，0x00002766十进制为10086，表示前一个节点长度为10086）</li></ul><p>因为节点的<code>previous_entry_length</code>属性记录了前一个节点的长度，所以程序可以通过指针运算，根据当前的起始地址计算出前一个节点的起始地址。压缩列表的从表尾向表头遍历操作就是使用这一原理实现的。</p><h4 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h4><p>节点的<code>encoding</code>属性记录了节点的<code>content</code>属性所保存数据的类型以及长度</p><ul><li>一字节、两字节或者五字节长，值的最高位为<strong>00、01或者10</strong>的是<strong>字节数组编码</strong>，这种编码表示节点的<code>content</code>属性保存着字节数组，数组的<strong>长度</strong>由编码除去最高两位之后的其他位记录</li><li>一字节长，值的最高位<strong>以11开头</strong>的是<strong>整数编码</strong>，这种编码表示节点的<code>content</code>属性保存着整数值，整数值的<strong>类型和长度</strong>由编码除去最高两位之后的其他位记录</li></ul><p>字节数组编码</p><table><thead><tr><th>编码</th><th>编码长度</th><th>content属性保存的值</th></tr></thead><tbody><tr><td>00xxxxxx</td><td>1字节</td><td>长度小于等于63字节的字节数组</td></tr><tr><td>01xxxxxx yyyyyyyy</td><td>2字节</td><td>长度小于等于16383字节的字节数组</td></tr><tr><td>10______ xxxxxxxx yyyyyyyy zzzzzzzz aaaaaaaa</td><td>5字节</td><td>长度小于等于4294967295字节的字节数组</td></tr></tbody></table><p>整数编码</p><table><thead><tr><th>编码</th><th>编码长度</th><th>content属性保存的值</th></tr></thead><tbody><tr><td>11000000</td><td>1字节</td><td>int16_t类型的整数</td></tr><tr><td>11010000</td><td>1字节</td><td>int32_t类型的整数</td></tr><tr><td>11100000</td><td>1字节</td><td>int64_t类型的整数</td></tr><tr><td>11110000</td><td>1字节</td><td>24位有符号整数</td></tr><tr><td>11111110</td><td>1字节</td><td>8位有符号整数</td></tr><tr><td>1111xxxx</td><td>1字节</td><td>使用这一编码的节点没有相应的content属性，因为编码本身的xxxx四个位已经保存了一个介于0-12的值，所以它无须content属性</td></tr></tbody></table><h4 id="content"><a href="#content" class="headerlink" title="content"></a>content</h4><p>节点的<code>content</code>属性负责保存节点的值，节点值可以是一个字节数组或整数，值的类型和长度由节点的<code>encoding</code>属性决定。例如：</p><table><thead><tr><th style="text-align:center">previous_entry_length</th><th>encoding</th><th>content</th></tr></thead><tbody><tr><td style="text-align:center">xxx</td><td>00001011</td><td>“hello world”</td></tr></tbody></table><ul><li>编码最高位00表示节点保存的是一个字节数组</li><li>编码后六位001011记录了字节数组长度为11</li><li>content属性保存了节点值字符串</li></ul><h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>前面说过，每个节点的<code>previous_entry_length</code>属性都记录了前一个节点的长度，现在考虑这样一种情况，在一个压缩列表中，又多个连续的、长度介于250字节到253字节之间的节点e1至eN</p><table><thead><tr><th>zlbytes</th><th>zltail</th><th>zllen</th><th>entry1</th><th>entry2</th><th>…</th><th>entryN</th><th>zlend</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>因为e1至eN所有节点的长度都小于254字节，所以记录这些节点的长度只需要1字节长的<code>previous_entry_length</code>属性，这时，如果我们将一个长度大于等于254字节的新节点new设置为压缩列表的表头节点</p><table><thead><tr><th>zlbytes</th><th>zltail</th><th>zllen</th><th>new-entry</th><th>entry1</th><th>…</th><th>entryN</th><th>zlend</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>因为e1的<code>previous_entry_length</code>属性仅长1字节，无法保存新节点的长度，所以程序将对压缩列表执行空间重分配操作，并将e1节点的<code>previous_entry_length</code>属性从原来的1字节扩展为5字节。现在，问题来了，e1之前介于250字节到253字节，现在新增四个字节，e1长度必定大于254字节，因此e2也保存不下，得再次对压缩列表执行空间重分配操作，正如e1引发了e2的扩展，e2也会引发e3的扩展……直到eN为止。<br>Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为<strong>“连锁更新(cascade)”</strong>，除了添加新节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新(如下，删除small节点，entry1会扩展为5字节）。</p><table><thead><tr><th>zlbytes</th><th>zltail</th><th>zllen</th><th>big(大于254)</th><th>small(小于254)</th><th>entry1</th><th>…</th><th>entryN</th><th>zlend</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>因为连锁更新在最坏的情况下需要对压缩列表执行N次空间重分配操作，二每次空间重分配最坏的复杂度为<code>O(N)</code>(即从entry1开始分配)，所以连锁更新最坏复杂度为<code>O(N^2)</code>，即压缩列表的很多API最坏复杂度为<code>O(N^2)</code>，如ziplistPush等。但是尽管连锁更新的复杂度较高，但是可能性几率不大，或者节点数少也不会造成太大性能问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>压缩列表是一种为节约内存而开发的顺序性数据结构</li><li>压缩列表被用作列表键和哈希键的底层实现之一</li><li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值</li><li>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;压缩列表&quot;&gt;&lt;a href=&quot;#压缩列表&quot; class=&quot;headerlink&quot; title=&quot;压缩列表&quot;&gt;&lt;/a&gt;压缩列表&lt;/h2&gt;&lt;p&gt;压缩列表&lt;br&gt;: (ziplist)是&lt;strong&gt;列表键(list)&lt;/strong&gt;和&lt;strong&gt;哈希键(hash)&lt;/strong&gt;的底层实现之一。当一个列表键只包含少量的列表项，并且每个列表项要么就是小整数值（具体见下文），要么就是长度比较短的字符串，那么Redis就会使用压缩列表来作为列表键的底层实现。(Redis3.2分支引入了&lt;a href=&quot;&amp;quot;https://pudgedd.github.io/2019/03/18/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(7&quot;&gt;quicklist&lt;/a&gt;%E2%80%94%E2%80%94quicklist/“)，并在4.0分支用&lt;code&gt;quicklist&lt;/code&gt;替代了&lt;code&gt;ziplist&lt;/code&gt;和&lt;code&gt;linkedlist&lt;/code&gt;成为了列表对象的底层编码)&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://pudgedd.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://pudgedd.github.io/tags/Redis/"/>
    
      <category term="数据结构" scheme="https://pudgedd.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="ziplist" scheme="https://pudgedd.github.io/tags/ziplist/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构与对象(5)——整数集合</title>
    <link href="https://pudgedd.github.io/2019/01/31/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(5)%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/"/>
    <id>https://pudgedd.github.io/2019/01/31/Redis数据结构与对象(5)——整数集合/</id>
    <published>2019-01-31T15:28:44.748Z</published>
    <updated>2019-02-12T08:43:27.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合<br>: (intset)是<strong>集合键（set）</strong>的底层实现之一，当一个集合只包含整数值元素（浮点数会让set的object encoding 变成hashtable），并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。<br><a id="more"></a></p><pre><code>redis&gt; SADD numbers 1 3 4 5&quot;4&quot;reids&gt; OBJECT ENCODING numbers&quot;intset&quot;redis&gt; SADD numbers 1.1&quot;1&quot;redis&gt; OBJECT ENCODING numbers&quot;hashtable&quot;</code></pre><h3 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h3><p>整数集合是Redis用于保存整数值的集合抽象数据结构，可以保存类型为<code>int16_t</code>、<code>int32_t</code>、<code>int64_t</code>的整数值，并且保证集合中不会出现重复元素。</p><p>整数集合<br>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding; <span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length; <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[]; <span class="comment">//保存元素的数组</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure></p><p>contents数组是整数集合的底层实现：整数集合的每个元素都是<code>contents</code>数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。<br>虽然intset将contents属性声明为int8_t类型数组，但实际上<code>contents</code>数组并并不保存任何<code>int8_t</code>类型的值，contents数组的真正类型取决于<code>encoding</code>属性的值，即如果<code>encoding</code>属性的值为<code>INTSET_ENC_INT16</code>，那么<code>contents</code>就是一个<code>int16_t</code>类型的数组，数组里每个元素占16位。</p><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。升级并添加分为三步进行：</p><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变</li><li>将新元素添加到底层数组里面</li></ol><p>举个例子：有一个<code>INTSET_ENC_INT16</code>编码的整数集合，集合中有1，2，3这三个<code>int16_t</code>的元素，底层数组的大小为<code>3*16=48</code>位。若把<code>int32_t</code>类型的65535添加到集合中，必须要对整个集合进行升级。首先要分配四个元素的空间，即<code>36*4=128</code>位。接下来把三个元素转换成<code>int32_t</code>类型，并放置到正确位上面，且维持有序性不变。最后将第四个元素加入，将整数集合encoding属性值从<code>INTSET_ENC_INT16</code>改为<code>INTSET_ENC_INT32</code>，并将<code>length</code>属性的值从3改为4。</p><p>因为每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已有的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为<code>O(N)</code>。</p><p>升级的好处：</p><ol><li>提升灵活性：因为C是静态类型语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面。但是，因为整数集合可以通过自动升级底层数组来适应新元素，所以我们可以随意将<code>int16_t</code>、<code>int32_t</code>、<code>int64_t</code>的整数添加到集合中，而不必担心出现类型错误</li><li>节约内存：当然，要让有一个数组可以同时保存<code>int16_t</code>、<code>int32_t</code>、<code>int64_t</code>的整数最简单的做法就是直接使用<code>int64_t</code>类型的数组作为整数集合的底层实现。不过这样一来会造成内存浪费的情况，而整数集合现在的做法既可以让集合能同时保存三种不同类型的值，又可以确保升级操作只会在有需要的时候进行，这可以尽量节省内存。</li></ol><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持在升级后的状态。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>整数集合是集合键的底层实现之一</li><li>整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型</li><li>升级操作为整数集合带来了操作上的灵活性，并且尽可能节约了内存</li><li>整数集合只支持升级操作，不支持降级操作</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;整数集合&quot;&gt;&lt;a href=&quot;#整数集合&quot; class=&quot;headerlink&quot; title=&quot;整数集合&quot;&gt;&lt;/a&gt;整数集合&lt;/h2&gt;&lt;p&gt;整数集合&lt;br&gt;: (intset)是&lt;strong&gt;集合键（set）&lt;/strong&gt;的底层实现之一，当一个集合只包含整数值元素（浮点数会让set的object encoding 变成hashtable），并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://pudgedd.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://pudgedd.github.io/tags/Redis/"/>
    
      <category term="数据结构" scheme="https://pudgedd.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="intset" scheme="https://pudgedd.github.io/tags/intset/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构与对象(4)——跳跃表</title>
    <link href="https://pudgedd.github.io/2019/01/31/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(4)%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <id>https://pudgedd.github.io/2019/01/31/Redis数据结构与对象(4)——跳跃表/</id>
    <published>2019-01-31T15:27:18.000Z</published>
    <updated>2019-02-12T08:43:20.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>跳跃表<br>: (skiplist)是一种有序的数据结构，支持平均<em>O</em>(log<em>N</em>)、最坏<em>O</em>(<em>N</em>)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。大部分情况下，跳跃表的效率可以和平衡树相媲美，且实现更为简单。<br><a id="more"></a><br>Redis使用跳跃表作为<strong>有序集合键(zset)</strong>的底层实现之一，如果一个有序集合包含的<strong>元素数量较多</strong>，又或者有序集合中的元素成员(member)是比<strong>较长的字符串</strong>时，Redis就会使用跳跃表来作为有序集合键的底层实现。</p><p>例如<br>: fruit-price是一个有序集合键，这个有序集合以水果名为成员，水果价钱为分值，保存了130款水果的价钱</p><pre><code>redis&gt; ZRANGE fruit-price 0 2 WITHSCORES1)&quot;banana&quot;2)&quot;5&quot;3)&quot;cherry&quot;4)&quot;6.5&quot;5)&quot;apple&quot;6)&quot;8&quot;redis&gt; ZCARD fruit-price(integer) 130</code></pre><p>fruit-price有序集合的所有数据都保存在一个跳跃表里面，其中每个跳跃表节点(node)都保存了一款水果的价钱信息，所有水果按价钱的高低从低到高在跳跃表里面排序。</p><p>和链表、字典等数据结构被广泛地应用在Redis内部不一样，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外跳跃表在Redis中没有其他用途。</p><h3 id="跳跃表原理"><a href="#跳跃表原理" class="headerlink" title="跳跃表原理"></a>跳跃表原理</h3><p>性质<br>: </p><ol><li>由很多层结构组成；</li><li>每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；</li><li>最底层的链表包含了所有的元素；</li><li>如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；</li><li>链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；</li></ol><p><img src="http://odwv9d2u8.bkt.clouddn.com/17-10-3/32571293.jpg" alt="跳跃表"></p><p>搜索<br>: 其基本原理就是从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。</p><p><img src="http://odwv9d2u8.bkt.clouddn.com/17-10-3/6620991.jpg" alt="跳跃表"></p><p>插入<br>: 既然要插入，首先需要确定插入的层数，这里有不一样的方法。1. 抛硬币法，只要是正面就累加，直到遇见反面才停止，最后记录正面的次数并将其作为要添加新元素的层；2. 统计概率，先给定一个概率p，产生一个0到1之间的随机数，如果这个随机数小于p，则将高度加1，直到产生的随机数大于概率p才停止，根据给出的结论，当概率为1/2或者是1/4的时候，整体的性能会比较好（其实当p为1/2的时候，也就是抛硬币的方法）。</p><p>当确定好要插入的层数以后，则需要将元素都插入到从最底层到第k层。</p><p>删除<br>: 在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。</p><h3 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h3><p>Redis的跳跃表由<code>redis.h/zskiplistNode</code>和<code>redis.h/zskiplist</code>两个结构定义，其中<code>zskiplistNode</code>结构用于表示跳跃表节点，而<code>zskiplist</code>结构则用于保存跳跃表节点的相关信息，比如结点的数量，指向表头节点和表位节点的指针等等。</p><p><img src="https://images2015.cnblogs.com/blog/878314/201701/878314-20170130211615120-320409943.png" alt="一个跳跃表"></p><p>上图展示了一个跳跃表示例，位于图片最左边的是<code>zskiplist</code>结构，该结构包含以下属性：</p><ul><li>header：指向跳跃表的表头节点</li><li>tail：指向跳跃表的表尾节点</li><li>level：记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</li><li>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</li></ul><p>位于<code>zskiplist</code>结构右方的是四个<code>zskiplistNode</code>结构，该结构包含以下属性：</p><p><strong>层(level)</strong>：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，依次类推。每个层都带有两个属性：<strong>前进指针</strong>和<strong>跨度</strong>。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</p><p><strong>后退(backward)指针</strong>：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</p><p><strong>分值(score)</strong>：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</p><p><strong>成员对象(obj)</strong>：各个节点中的o1、o2和o3是节点所保存的成员对象。<br>  注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到，所以图中省略了这些部分，只显示了表头节点的各个层。</p><p>跳跃表节点<br>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">//后退指针</span></span><br><span class="line">    <span class="keyword">double</span> score;<span class="comment">//分值</span></span><br><span class="line">    robj *obj;<span class="comment">//成员对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span> <span class="comment">//层</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span>  <span class="comment">//前进指针</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;  <span class="comment">//跨度</span></span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></p><ol><li><p>层：跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。<br>每次创建一个新跳跃表节点的时候，程序根据幂次定律(power law，越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。<br>下图分别展示了三个高度为1层、3层和5层的节点，因为C语言的数组索引总是从0开始的，所以节点的第一层是level[0]，而第二层是level[1]，依次类推。</p></li><li><p>前进指针</p></li><li><p>跨度：层的跨度(<code>level[i].span</code>属性)用于记录两个节点之间的距离：两个节点之间的跨度越大，它们相距得就越远。指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。初看上去，很容易以为跨度和遍历操作有关，但实际上并不是这样的，遍历操作只使用前进指针就可以完成了，跨度实际上是用来计算排位(rank)的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p></li><li><p>后退指针：节点的后退指针(backward属性)用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p></li><li><p>分值和成员：节点的分值(score属性)是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。<br>节点的成员对象(obj属性)是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。<br>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分至相同的节点将按照成员对象在字典中的大小来进行排序，成员对象较小的节点会排在前面(靠近表头的方向)，而成员对象较大的节点则会排在后面(靠近表尾的方向)。</p></li></ol><p>跳跃表<br>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span>    <span class="comment">//header指向跳跃表的表头节点，tail指向跳跃表的表尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;   <span class="comment">//记录跳跃表的长度，也即是，跳跃表目前包含节点的数量(表头节点不计算在内)</span></span><br><span class="line">    <span class="keyword">int</span> level;  <span class="comment">//记录目前跳跃表内，层数最大的那个节点的层数(表头节点的层数不计算在内)</span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure></p><p>header和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为<em>O</em>(1)。<br>通过length属性，可以在<em>O</em>(1)复杂度内返回跳跃表的长度。<br>level属性用于在<em>O</em>(1)复杂度内获取跳跃表中层高最大的那个节点的层数量（不计算表头节点的层高）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>跳跃表是有序集合的底层实现之一</li><li>Redis的跳跃表实现由<code>zskiplist</code>和<code>zskiplistNode</code>两个结构组成，其中<code>zskiplist</code>用于保存跳跃表信息（表头节点、表尾节点、长度），而<code>zskiplistNode</code>则用于表示跳跃表节点</li><li>每个跳跃表节点的层高都是1至32之间的<strong>随机数</strong></li><li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象（指向SDS的一个指针）必须是唯一的</li><li>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象在字典序中的大小进行排序</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;跳跃表&quot;&gt;&lt;a href=&quot;#跳跃表&quot; class=&quot;headerlink&quot; title=&quot;跳跃表&quot;&gt;&lt;/a&gt;跳跃表&lt;/h2&gt;&lt;p&gt;跳跃表&lt;br&gt;: (skiplist)是一种有序的数据结构，支持平均&lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)、最坏&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。大部分情况下，跳跃表的效率可以和平衡树相媲美，且实现更为简单。&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://pudgedd.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://pudgedd.github.io/tags/Redis/"/>
    
      <category term="数据结构" scheme="https://pudgedd.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="跳跃表" scheme="https://pudgedd.github.io/tags/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构与对象(3)——字典</title>
    <link href="https://pudgedd.github.io/2019/01/31/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(3)%E2%80%94%E2%80%94%E5%AD%97%E5%85%B8/"/>
    <id>https://pudgedd.github.io/2019/01/31/Redis数据结构与对象(3)——字典/</id>
    <published>2019-01-31T15:23:17.000Z</published>
    <updated>2019-02-12T08:43:14.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典，又称为符号表(symbol table)、关联数组(associative array)或映射(map)，是一种用于保存键值对的抽象数据结构。字典中的每个键都是独一无二的，程序可以在字典中通过键查找与之关联的值，或进行更新删除等操作。<br><a id="more"></a><br>Redis的数据库就是使用字典来作为底层实现的。例如：</p><pre><code>redis&gt;SET msg &quot;hello world&quot;OK</code></pre><p>在数据库中创建了一个键为”msg”,值为”hello world”的键值对，保存在字典中。<br>除了用来表示数据库外，字典还是<strong>哈希键</strong>的底层实现之一。</p><pre><code>redis&gt;  HMSET user name &quot;kendall&quot; sex &quot;man&quot;OKredis&gt;  HGETALL user1) &quot;name&quot;2) &quot;kendall&quot;3) &quot;sex&quot;4) &quot;man&quot;</code></pre><p><code>user</code>就是一个一个包含2个键值对的哈希键。</p><p>Redis的字典使用哈希表作为底层实现，一个哈希表可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><p>哈希表<br>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;<span class="comment">//哈希表大小掩码，总是等于size-1，用于计算索引值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure></p><p><code>table</code>是一个数组，数组中的每一个元素都是一个指向dictEntry结构的指针，每个dictEntry结构都保存着一个键值对。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> key;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span><span class="comment">//哈希冲突时，采用链表法解决</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure></p><p>字典<br>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    dictType *type;<span class="comment">//类型特定函数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;<span class="comment">//私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];<span class="comment">//哈希表</span></span><br><span class="line">    <span class="keyword">int</span> trehashidx;<span class="comment">//rehash索引，当rehash不进行时，为-1；</span></span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure></p><p>了解：<code>type</code>属性是指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，<code>privdate</code>保存了传给那些函数的可选参数。</p><p><code>ht</code>是一个长度为2的数组，包含了两个dictht哈希表。一般情况下字典只使用<code>ht[0]</code>哈希表，<code>ht[1]</code>只有在进行rehash的时候使用。<code>rehashidx</code>记录了rehash的进度。</p><p>哈希算法<br>: 当要将一个新的键值对添加到字典时，程序需要先根据键值对的键计算出哈希值和索引值，然后根据索引值将节点放到韩系标书组的指定索引上面。Redis使用MurmurHash2算法来计算哈希值(Redis v3.0)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure></p><h3 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h3><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上时，我们称这些键发生了冲突。Redis的哈希表使用了<strong>链地址法</strong>解决键冲突，每个哈希表节点都由一个next指针，被分配到同一个索引上的节点可以用next连接成单向链表，新加入的节点总是排在所有节点的前面。</p><h3 id="扩容（收缩）和rehash"><a href="#扩容（收缩）和rehash" class="headerlink" title="扩容（收缩）和rehash"></a>扩容（收缩）和rehash</h3><p>哈希表的键值对会逐渐的增加或减少，为了让哈希表的负载因子(load factor)，维持在一个合理的范围，程序需要对哈希表进行相应的扩容或收缩。当满足<br>以下两点任意一点时，扩容开始。当满足负<strong>载因子小于0.1</strong>时，进行收缩。</p><ol><li>服务器目前没有在执行<em>BGSAVE</em>命令或者<em>BGREWRITEAOF</em>命令，并且哈希表的负载因子大于等于1</li><li>服务器目前正在执行<em>BGSAVE</em>命令或者<em>BGREWRITEAOF</em>命令，并且哈希表的负载因子大于等于5</li></ol><p>其中负载因子计算方法为：</p><pre><code>load_factor = ht[0].used/dictht.size</code></pre><p>步骤如下：</p><ol><li>为字典的<code>ht[1]</code>分配空间，如果执行的是扩展操作，那么<code>ht[1]</code>的大小为大于等于<code>ht[0].used*2</code>的最小2^n；若是收缩操作，那么<code>ht[1]</code>的大小为大于等于<code>ht[0].used</code>的最小2^n。</li><li>将保存在<code>ht[0]</code>中的所有键值对rehash（重新计算键的哈希和索引）到<code>ht[1]</code>上，并将键值对放置到<code>ht[1]</code>。</li><li>当<code>ht[0]</code>的所有键值对都迁移到了<code>ht[1]</code>上后，释放<code>ht[0]</code>，将<code>ht[1]</code>设置为<code>ht[0]</code>，并在<code>ht[1]</code>新建一个空白的哈希表，为下一次rehash做准备。</li></ol><p>Redis的rehash时<strong>渐进式</strong>的，即不是一次性、集中式完成的，而是分多次完成。这样做是避免键值对过多时，庞大的计算量导致服务器停止服务。渐进式的步骤如下：</p><ol><li>为<code>ht[1]</code>分配空间</li><li>在字典中维持<code>rehashidx</code>,将其值设置为0，表示rehash正式开始</li><li>在rehash期间，每次对字典的增删查改，程序都会顺带将<code>ht[0]</code>哈希表在<code>rehashidx</code>索引上的所有键值对rehash到<code>ht[1]</code>，当rehash工作完成后，<code>rehashidx</code>增加1</li><li>随着字典操作不断执行，最终某个时间上，ht[0]的所有键值对都会被rehash至<code>ht[1]</code>,<code>rehashidx</code>设为-1，代表rehash完成。</li><li>rehash过程中，字典会同时使用两个哈希表，如<code>ht[0]</code>没找到，会继续去<code>ht[1]</code>找。而添加一律会被保存在<code>ht[1]</code>。</li></ol><p>举例: <code>set msg HelloWorld</code>这个命令执行以后，redis会在<code>dict-&gt;ht-&gt;dictht-&gt;table</code>中加入一个<code>dictEntry</code>，entry的位置由<code>dict</code>内置的hash算法(比如MurmurHash2)与大小掩码作与运算得出，这个<code>dictEntry</code>包含了<code>key-value</code>和<code>next</code>属性，key和value是redis的<code>SDS</code>简单动态字符串的抽象类。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>字典被广泛用于实现Redis（远程字典服务）的各种功能，其中包括数据库和哈希键。</li><li>Redis中的字典使用哈希表作为底层实现，每个字典待优两个哈希表，一个平时使用，另一个仅在进行rehash时使用</li><li>Redis目前使用MurmurHash2算法计算键的哈希值</li><li>哈希表使用链地址法来解决冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表</li><li>在对哈希表进行扩展或收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程不是一次性完完成的，而是伴随着每一次增删改查渐进式完成的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a&gt;字典&lt;/h2&gt;&lt;p&gt;字典，又称为符号表(symbol table)、关联数组(associative array)或映射(map)，是一种用于保存键值对的抽象数据结构。字典中的每个键都是独一无二的，程序可以在字典中通过键查找与之关联的值，或进行更新删除等操作。&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://pudgedd.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://pudgedd.github.io/tags/Redis/"/>
    
      <category term="数据结构" scheme="https://pudgedd.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="字典" scheme="https://pudgedd.github.io/tags/%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构与对象(2)——链表</title>
    <link href="https://pudgedd.github.io/2019/01/31/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(2)%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"/>
    <id>https://pudgedd.github.io/2019/01/31/Redis数据结构与对象(2)——链表/</id>
    <published>2019-01-31T15:16:58.000Z</published>
    <updated>2019-01-31T15:37:20.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表提供了高效的节点重排能力，以及顺序性节点的访问方式，并且可以通过增删节点来灵活地调整长度。Redis中的<strong>列表键</strong>(list)的底层实现之一就是链表。当一个链表键包含了较多元素，又或者列表中包含的元素都是较长的字符串时，Redis就会使用链表作为列表键的底层实现。（实际上链表还被广泛用于实现Redis的各种功能，比如发布与订阅、慢查询、监视器等）<br><a id="more"></a></p><pre><code>redis&gt;LLEN integers(integer) 1024redis&gt;LRANGE integers 0 31)&quot;1&quot;2)&quot;2&quot;3)&quot;3&quot;</code></pre><p>integers列表键底层实现就是一个链表，每个节点都保存了一个整数值。</p><p>Redis链表的实现<br>: 每个链表节点都包含了指向prev和next的两个指针，同时还有保存节点值的value指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure></p><p>Redis list结构<br>: list结构为链表提供了表头指针，表尾指针，以及链表长度计数器len，这么做的好处是获取prev和next节点、获取head和tail节点、获取链表长度的时间复杂度均为O(1)。此外还提供了三个特定函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> *(*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> *(*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h2&gt;&lt;p&gt;链表提供了高效的节点重排能力，以及顺序性节点的访问方式，并且可以通过增删节点来灵活地调整长度。Redis中的&lt;strong&gt;列表键&lt;/strong&gt;(list)的底层实现之一就是链表。当一个链表键包含了较多元素，又或者列表中包含的元素都是较长的字符串时，Redis就会使用链表作为列表键的底层实现。（实际上链表还被广泛用于实现Redis的各种功能，比如发布与订阅、慢查询、监视器等）&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://pudgedd.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://pudgedd.github.io/tags/Redis/"/>
    
      <category term="数据结构" scheme="https://pudgedd.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="https://pudgedd.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构与对象(1)——简单动态字符串SDS</title>
    <link href="https://pudgedd.github.io/2018/12/28/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1(1)%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS/"/>
    <id>https://pudgedd.github.io/2018/12/28/Redis数据结构与对象(1)——简单动态字符串SDS/</id>
    <published>2018-12-28T15:51:22.000Z</published>
    <updated>2019-02-12T08:42:47.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单动态字符串-SDS"><a href="#简单动态字符串-SDS" class="headerlink" title="简单动态字符串-SDS"></a>简单动态字符串-SDS</h2><p>Redis是由C语言编写的，但Redis没有直接使用C语言传统的字符串表示，而是自己构建了一种叫做简单动态字符串（simple dynamic string, SDS）的抽象类型，除了用来保存字符串外，SDS还被用作缓冲区，如AOF缓冲区。<br><a id="more"></a><br>当你在redis客户端执行命令：</p><pre><code>redis&gt;SET msg &quot;hello world&quot;OK</code></pre><p>那么Redis将会创建一个新的键值对，而这个键值对的键”msg”和键值对的值”hello world”底层实现就是保存了字符串的SDS。</p><p>SDS定义<br>: </p><pre><code class="c"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>{</span>        <span class="keyword">int</span> len; <span class="comment">//记录buf数组中已使用的字节的数量</span>        <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">//记录buf数组中未使用的字节的数量</span>        <span class="keyword">char</span> buf[]; <span class="comment">//保存字符串char的数组</span>    }</code></pre><p>SDS的结构其实就是一个字节数组，如字符串”redis”，那么buf就是一个保存了[‘r’,’e’,’d’,’i’,’s’,’\0’]的char数组（’\0’是C语言的一个惯例，redis遵守这个惯例是为了直接重用C库里的一些字符串函数）</p><h4 id="为什么要用SDS？"><a href="#为什么要用SDS？" class="headerlink" title="为什么要用SDS？"></a>为什么要用SDS？</h4><p>C语言使用的字符串方式，并不能满足Redis对字符串安全性、效率以及功能的要求。</p><ol><li><p><strong>常数复杂度获取字符串长度</strong>：C获取字符串长度复杂度为O(<em>N</em>)，而SDS保存了len属性，获取字符串长度复杂度为O(1)</p></li><li><p><strong>杜绝缓冲区溢出</strong>：C字符串不记录自身长度带来的另一个问题就是容易造成缓冲区溢出，例如内存中紧邻的s1-“redis”和s2-“mongo”，如果此时执行<code>strcat(s1,&quot;cluster&quot;)</code>，且没有在此之前为s1分配足够的空间，那么s2保存的内容将被意外的修改。与C不同，当SDS的API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需，不满足的话，API会自动将SDS的空间扩展至所需修改的大小，然后再进行实际的修改，所以SDS不需要手动修改SDS的空间大小，也不会出现缓冲区溢出问题。</p></li><li><p><strong>减少修改字符串时带来的内存重分配次数</strong>：C在每次进行字符串修改时（增长或缩短），总要进行一次内存重分配操作，而内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以比较耗时。为了避免这个缺陷，SDS通过未使用空间接触字符串长度和底层数组长度的关联。buf的数组长度可能包含未使用的字节，由free属性记录。实际上SDS用未使用空间实现了两种优化策略。<br>3.1 <strong>空间预分配</strong>：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须的空间，还会分配额外的未使用空间。若修改后的SDS长度（len属性）小于1MB，那么分配和len属性同样大小的未使用空间，即buf的实际长度为<code>len+len+1byte</code>;若长度大于1MB，那么程序会分配1MB的未使用空间，即buf的实际长度为<code>lne+1MB+1byte</code>。<br>3.2 <strong>惰性空间释放</strong>：执行字符串缩短操作后，SDS并不会立即释放多余的空间，而是保留作为未使用空间，以减少内存重分配操作，并未将来可能的增长提供优化。当然SDS也提供主动释放空间的API。</p></li><li><p><strong>二进制安全</strong>：C以”\0”为结尾标记，若有使用此特殊字符的字符串，则无法用C字符串保存。而SDS虽然保留了C以”\0”结尾的惯例，但并不以此来识别字符串是否结束，可以说数据在写入SDS是什么样的，它被读取出来就是什么样的。因此二进制安全的SDS可以保存任意格式的二进制数据。</p></li><li><p><strong>兼容部分的C字符串函数</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单动态字符串-SDS&quot;&gt;&lt;a href=&quot;#简单动态字符串-SDS&quot; class=&quot;headerlink&quot; title=&quot;简单动态字符串-SDS&quot;&gt;&lt;/a&gt;简单动态字符串-SDS&lt;/h2&gt;&lt;p&gt;Redis是由C语言编写的，但Redis没有直接使用C语言传统的字符串表示，而是自己构建了一种叫做简单动态字符串（simple dynamic string, SDS）的抽象类型，除了用来保存字符串外，SDS还被用作缓冲区，如AOF缓冲区。&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://pudgedd.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://pudgedd.github.io/tags/Redis/"/>
    
      <category term="数据结构" scheme="https://pudgedd.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="SDS" scheme="https://pudgedd.github.io/tags/SDS/"/>
    
  </entry>
  
</feed>
